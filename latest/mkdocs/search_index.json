{
    "docs": [
        {
            "location": "/", 
            "text": "SnpArrays.jl\n\n\nCompressed storage for SNP data\n\n\nSnpArrays.jl\n implements the \nSnpArray\n, \nSnpData\n and \nHaplotypeArray\n types for handling biallelic genotypes.\n\n\n\n\nPackage Features\n\n\n\n\nRead and write \nPlink binary files\n.  \n\n\nCalculate summary statistics (minor allele frequencies, minor allele, count of missing genotypes).  \n\n\nSimple and intuitive manipulation (subsetting, adjoining, assignment, imputation) of array of genotypes.  \n\n\nGenerate random genotypes according to minor allele frequencies.  \n\n\nFilter an array of genotypes subject to minimum genotyping success rate per individual and per SNP.  \n\n\nConvert genotypes into dense or sparse arrays of real numbers (minor allele counts).  \n\n\nCalculate various empirical kinship matrices.  \n\n\nExtract principal components.  \n\n\n\n\n\n\nInstallation\n\n\nUse the Julia package manager to install SnpArrays.jl.\n\n\nPkg\n.\nclone\n(\ngit@github.com:OpenMendel/SnpArrays.jl.git\n)\n\n\n\n\n\n\nThis package supports Julia \n0.4\n.\n\n\n\n\nManual Outline\n\n\n\n\nSnpArray\n\n\nConstructor\n\n\nSummary statistics\n\n\nFiltering\n\n\nRandom genotypes generation\n\n\nSubsetting\n\n\nAssignment\n\n\nConvert, copy and imputation\n\n\nEmpirical kinship matrix\n\n\nPrincipal components\n\n\n\n\n\n\nSnpData\n\n\nHaplotypeArray\n\n\nConstructor\n\n\nSummary statistics\n\n\nSubsetting and assignment\n\n\nCopy and convert", 
            "title": "Home"
        }, 
        {
            "location": "/#snparraysjl", 
            "text": "Compressed storage for SNP data  SnpArrays.jl  implements the  SnpArray ,  SnpData  and  HaplotypeArray  types for handling biallelic genotypes.", 
            "title": "SnpArrays.jl"
        }, 
        {
            "location": "/#package-features", 
            "text": "Read and write  Plink binary files .    Calculate summary statistics (minor allele frequencies, minor allele, count of missing genotypes).    Simple and intuitive manipulation (subsetting, adjoining, assignment, imputation) of array of genotypes.    Generate random genotypes according to minor allele frequencies.    Filter an array of genotypes subject to minimum genotyping success rate per individual and per SNP.    Convert genotypes into dense or sparse arrays of real numbers (minor allele counts).    Calculate various empirical kinship matrices.    Extract principal components.", 
            "title": "Package Features"
        }, 
        {
            "location": "/#installation", 
            "text": "Use the Julia package manager to install SnpArrays.jl.  Pkg . clone ( git@github.com:OpenMendel/SnpArrays.jl.git )   This package supports Julia  0.4 .", 
            "title": "Installation"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "SnpArray  Constructor  Summary statistics  Filtering  Random genotypes generation  Subsetting  Assignment  Convert, copy and imputation  Empirical kinship matrix  Principal components    SnpData  HaplotypeArray  Constructor  Summary statistics  Subsetting and assignment  Copy and convert", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/man/snparray/", 
            "text": "SnpArray\n\n\nSnpArray\n is an array of \nTuple{Bool,Bool}\n and adopts the same coding as the \nPlink binary format\n. If \nA1\n and \nA2\n are the two alleles, the coding rule is  \n\n\n\n\n\n\n\n\nGenotype\n\n\nSnpArray\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n(false,false)\n\n\n\n\n\n\nA1,A2\n\n\n(false,true)\n\n\n\n\n\n\nA2,A2\n\n\n(true,true)\n\n\n\n\n\n\nmissing\n\n\n(true,false)\n\n\n\n\n\n\n\n\nThe code \n(true,false)\n is reserved for missing genotype. Otherwise, the bit \ntrue\n represents one copy of allele \nA2\n. In a two-dimensional \nSnpArray\n, each row is a person and each column is a SNP.\n\n\nFor complete genotype data, for example, after imputation, consider using the \nHaplotypeArray\n type.\n\n\n\n\nConstructor\n\n\nThere are various ways to initialize a \nSnpArray\n.  \n\n\n\n\nSnpArray\n can be initialized from \nPlink binary files\n, say the sample data set hapmap3:\n\n\n\n\n;\nls\n \n-\nal\n \nhapmap3\n.*\n\n\n\n\n\n\n-rw-r--r--  1 hzhou3  staff  1128171 Jul 12 04:45 hapmap3.bed\n-rw-r--r--  1 hzhou3  staff   388672 Jul  7 18:09 hapmap3.bim\n-rw-r--r--  1 hzhou3  staff     7136 Jul  7 18:09 hapmap3.fam\n-rw-r--r--  1 hzhou3  staff   332960 Jul  7 18:09 hapmap3.map\n\n\n\n\n\nusing\n \nSnpArrays\n\n\nhapmap\n \n=\n \nSnpArray\n(\nhapmap3\n)\n\n\n\n\n\n\n324x13928 SnpArrays.SnpArray{2}:\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (false,true)  (false,true)      (false,true)  (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (false,true)  (true,true)    \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)   \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n \u22ee                                         \u22f1                           \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n\n\n\n\n\nBy default, the constructor figures out the number of individuals and SNPs from the \n.bim\n and \n.fam\n files.\n\n\n# rows are people; columns are SNPs\n\n\npeople\n,\n \nsnps\n \n=\n \nsize\n(\nhapmap\n)\n\n\n\n\n\n\n(324,13928)\n\n\n\n\n\nAlternatively, users can supply keyword arguments \npeople\n and \nsnps\n to the constructor. In this case only the \n.bed\n file needs to be present.\n\n\nhapmap\n \n=\n \nSnpArray\n(\nhapmap3\n;\n \npeople\n \n=\n \n324\n,\n \nsnps\n \n=\n \n13928\n)\n\n\n\n\n\n\n324x13928 SnpArrays.SnpArray{2}:\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (false,true)  (false,true)      (false,true)  (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (false,true)  (true,true)    \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)   \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n \u22ee                                         \u22f1                           \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n\n\n\n\n\nInternally \nSnpArray\n stores data as \nBitArray\ns and consumes approximately the same amount of memory as the Plink \nbed\n file size.\n\n\n# memory usage, bed file size\n\n\nBase\n.\nsummarysize\n(\nhapmap\n),\n \nfilesize\n(\nhapmap3.bed\n)\n\n\n\n\n\n\n(1128256,1128171)\n\n\n\n\n\n\n\nSnpArray\n can be initialized from a matrix of A1 allele counts.\n\n\n\n\nSnpArray\n(\nrand\n(\n0\n:\n2\n,\n \n5\n,\n \n3\n))\n\n\n\n\n\n\n5x3 SnpArrays.SnpArray{2}:\n (true,true)    (false,false)  (true,true)  \n (false,false)  (true,true)    (false,false)\n (false,true)   (true,true)    (false,true) \n (false,true)   (true,true)    (false,true) \n (false,false)  (false,true)   (false,true)\n\n\n\n\n\n\n\nSnpArray(m, n)\n generates an m by n \nSnpArray\n of all A1 alleles.\n\n\n\n\ns\n \n=\n \nSnpArray\n(\n5\n,\n \n3\n)\n\n\n\n\n\n\n5x3 SnpArrays.SnpArray{2}:\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n\n\n\n\n\n\n\nSummary statistics\n\n\nsummarize\n function computes the following summary statistics of a \nSnpArray\n:  \n\n\n\n\nmaf\n: minor allele frequencies, taking into account of missingness.  \n\n\nminor_allele\n: a \nBitVector\n indicating the minor allele for each SNP.   \nminor_allele[j]==true\n means A1 is the minor allele for SNP j; \nminor_allele[j]==false\n means A2 is the minor allele for SNP j.  \n\n\nmissings_by_snp\n: number of missing genotypes for each snp.  \n\n\nmissings_by_person\n: number of missing genotypes for each person.  \n\n\n\n\nmaf\n,\n \nminor_allele\n,\n \nmissings_by_snp\n,\n \nmissings_by_person\n \n=\n \nsummarize\n(\nhapmap\n)\n\n\n# minor allele frequencies\n\n\nmaf\n\n\n\n\n\n\n1x13928 Array{Float64,2}:\n 0.0  0.0776398  0.324074  0.191589  \u2026  0.00154321  0.0417957  0.00617284\n\n\n\n\n\n# total number of missing genotypes\n\n\nsum\n(\nmissings_by_snp\n),\n \nsum\n(\nmissings_by_person\n)\n\n\n\n\n\n\n(11894,11894)\n\n\n\n\n\n# proportion of missing genotypes\n\n\nsum\n(\nmissings_by_snp\n)\n \n/\n \nlength\n(\nhapmap\n)\n\n\n\n\n\n\n0.0026356890108565393\n\n\n\n\n\n\n\nFiltering\n\n\nIn almost all analyses, SNPs and individuals with low genotyping success rates are ignored. This filtering step is an important tool for removing likely false positives from association testing, as genotyping failure often occurs preferentially in cases or controls, or is correlated with the quantitative trait. \nfilter(s, min_success_rate_per_snp, min_success_rate_per_person)\n does filtering according to the specified success rates for SNPs and people. Default is 0.98 for both.\n\n\n# filtering SNPs and people to have both success rates above 0.98\n\n\nsnp_idx\n,\n \nperson_idx\n \n=\n \nfilter\n(\nhapmap\n,\n \n0.98\n,\n \n0.98\n)\n\n\n# summary statistics of the filtered SnpArray\n\n\n_\n,\n \n_\n,\n \nmissings_by_snp_filtered\n,\n \nmissings_by_person_filtered\n \n=\n \nsummarize\n(\nsub\n(\nhapmap\n,\n \nperson_idx\n,\n \nsnp_idx\n));\n\n\n\n\n\n\n# minimum SNP genotyping success rate after filtering \u2265 0.98\n\n\n1.0\n \n-\n \nmaximum\n(\nmissings_by_snp_filtered\n)\n \n/\n \nlength\n(\nmissings_by_person_filtered\n)\n\n\n\n\n\n\n0.9813084112149533\n\n\n\n\n\n# minimum person genotyping success rate after filtering \u2265 0.98\n\n\n1.0\n \n-\n \nmaximum\n(\nmissings_by_person_filtered\n)\n \n/\n \nlength\n(\nmissings_by_snp_filtered\n)\n\n\n\n\n\n\n0.9818511796733213\n\n\n\n\n\n\n\nRandom genotypes generation\n\n\nrandgeno(a1freq)\n generates a random genotype according to A1 allele frequency \na1freq\n.\n\n\nrandgeno\n(\n0.5\n)\n\n\n\n\n\n\n(false,true)\n\n\n\n\n\nrandgeno(maf, minor_allele)\n generates a random genotype according to minor allele frequency \nmaf\n and whether the minor allele is A1 (\nminor_allele==true\n) or A2 (\nminor_allele==false\n).\n\n\nrandgeno\n(\n0.25\n,\n \ntrue\n)\n\n\n\n\n\n\n(false,true)\n\n\n\n\n\nrandgeno(n, maf, minor_allele)\n generates a vector of random genotypes according to a common minor allele frequency \nmaf\n and the minor allele.\n\n\nrandgeno\n(\n10\n,\n \n0.25\n,\n \ntrue\n)\n\n\n\n\n\n\n10-element SnpArrays.SnpArray{1}:\n (true,true)  \n (false,false)\n (true,true)  \n (false,true) \n (false,true) \n (true,true)  \n (true,true)  \n (false,true) \n (false,true) \n (false,true)\n\n\n\n\n\nrandgeno(m, n, maf, minor_allele)\n generates a random $m$-by-$n$ \nSnpArray\n according to a vector of minor allele frequencies \nmaf\n and a minor allele indicator vector. The lengths of both vectors should be \nn\n.\n\n\n# this is a random replicate of the hapmap data\n\n\nrandgeno\n(\nsize\n(\nhapmap\n),\n \nmaf\n,\n \nminor_allele\n)\n\n\n\n\n\n\n324x13928 SnpArrays.SnpArray{2}:\n (true,true)  (false,true)  (false,true)   \u2026  (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (false,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (false,true)\n (true,true)  (true,true)   (true,true)    \u2026  (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true) \n (true,true)  (true,true)   (false,false)     (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (false,true)  (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true) \n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true) \n \u22ee                                         \u22f1                            \n (true,true)  (true,true)   (false,false)     (false,true)  (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)    \u2026  (true,true)   (true,true) \n (true,true)  (false,true)  (true,true)       (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)    \u2026  (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (false,true)  (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n\n\n\n\n\n\n\nSubsetting\n\n\nSubsetting a \nSnpArray\n works the same way as subsetting any other arrays.\n\n\n# genotypes of the 1st person\n\n\nhapmap\n[\n1\n,\n \n:]\n\n\n\n\n\n\n1x13928 SnpArrays.SnpArray{2}:\n (true,true)  (true,true)  (false,false)  \u2026  (true,true)  (true,true)\n\n\n\n\n\n# genotypes of the 5th SNP\n\n\nhapmap\n[:,\n \n5\n]\n\n\n\n\n\n\n324-element SnpArrays.SnpArray{1}:\n (true,true)  \n (true,true)  \n (false,true) \n (false,true) \n (true,true)  \n (false,false)\n (false,false)\n (true,true)  \n (true,true)  \n (true,true)  \n (true,true)  \n (true,true)  \n (false,true) \n \u22ee            \n (false,false)\n (true,true)  \n (false,true) \n (true,true)  \n (true,true)  \n (true,true)  \n (true,true)  \n (true,true)  \n (false,true) \n (true,true)  \n (true,true)  \n (true,true)\n\n\n\n\n\n# subsetting both persons and SNPs\n\n\nhapmap\n[\n1\n:\n5\n,\n \n5\n:\n10\n]\n\n\n\n\n\n\n5x6 SnpArrays.SnpArray{2}:\n (true,true)   (true,true)  (false,true)  \u2026  (true,true)   (false,true)\n (true,true)   (true,true)  (true,true)      (true,true)   (false,true)\n (false,true)  (true,true)  (true,true)      (false,true)  (true,true) \n (false,true)  (true,true)  (true,true)      (true,true)   (false,true)\n (true,true)   (true,true)  (true,true)      (true,true)   (false,true)\n\n\n\n\n\n# filter out rare SNPs with MAF \n 0.05\n\n\nhapmap\n[:,\n \nmaf\n \n.\n\u2265\n \n0.05\n]\n\n\n\n\n\n\n324x12085 SnpArrays.SnpArray{2}:\n (true,true)   (false,false)  (true,true)   \u2026  (false,true)  (false,true)\n (false,true)  (false,true)   (false,true)     (true,true)   (true,true) \n (true,true)   (false,true)   (false,true)     (true,true)   (true,true) \n (true,true)   (false,true)   (true,true)      (false,true)  (false,true)\n (true,true)   (false,true)   (false,true)     (true,true)   (true,true) \n (false,true)  (true,true)    (true,true)   \u2026  (false,true)  (false,true)\n (true,true)   (true,true)    (true,true)      (true,true)   (true,true) \n (true,true)   (false,false)  (true,true)      (true,true)   (true,true) \n (true,true)   (false,true)   (false,true)     (true,true)   (true,true) \n (true,true)   (false,true)   (true,true)      (false,true)  (false,true)\n (true,true)   (false,true)   (true,true)   \u2026  (true,true)   (true,true) \n (true,true)   (true,true)    (false,true)     (false,true)  (false,true)\n (true,true)   (false,false)  (true,true)      (false,true)  (false,true)\n \u22ee                                          \u22f1                            \n (true,true)   (false,true)   (true,true)      (false,true)  (false,true)\n (true,true)   (false,false)  (true,true)      (false,true)  (false,true)\n (true,true)   (false,false)  (true,true)      (true,true)   (true,true) \n (true,true)   (false,false)  (false,true)  \u2026  (true,true)   (true,true) \n (true,true)   (false,true)   (true,true)      (true,true)   (true,true) \n (true,true)   (true,true)    (false,true)     (false,true)  (false,true)\n (true,true)   (false,true)   (false,true)     (false,true)  (false,true)\n (true,true)   (false,true)   (true,true)      (true,true)   (true,true) \n (true,true)   (false,false)  (true,true)   \u2026  (false,true)  (false,true)\n (true,true)   (false,true)   (false,true)     (false,true)  (false,true)\n (true,true)   (false,false)  (false,true)     (false,true)  (false,true)\n (true,true)   (false,false)  (true,true)      (true,true)   (true,true)\n\n\n\n\n\n# filter out individuals with genotyping success rate \n 0.90\n\n\nhapmap\n[\nmissings_by_person\n \n/\n \npeople\n \n.\n \n0.1\n,\n \n:]\n\n\n\n\n\n\n220x13928 SnpArrays.SnpArray{2}:\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (false,true)  (false,true)      (false,true)  (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)   \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (false,true)  (false,true)   \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n \u22ee                                         \u22f1                           \n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)   \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n\n\n\n\n\nsub()\n and \nslice()\n create views of subarray without copying data and improve efficiency in many calculations.\n\n\nmafcommon\n,\n \n=\n \nsummarize\n(\nsub\n(\nhapmap\n,\n \n:,\n \nmaf\n \n.\n\u2265\n \n0.05\n))\n\n\nmafcommon\n\n\n\n\n\n\n1x12085 Array{Float64,2}:\n 0.0776398  0.324074  0.191589  \u2026  0.310937  0.23913  0.23913  0.23913\n\n\n\n\n\n\n\nAssignment\n\n\nIt is possible to assign specific genotypes to a \nSnpArray\n entry.\n\n\nhapmap\n[\n1\n,\n \n1\n]\n\n\n\n\n\n\n(true,true)\n\n\n\n\n\nhapmap\n[\n1\n,\n \n1\n]\n \n=\n \n(\nfalse\n,\n \ntrue\n)\n\n\nhapmap\n[\n1\n,\n \n1\n]\n\n\n\n\n\n\n(false,true)\n\n\n\n\n\nhapmap\n[\n1\n,\n \n1\n]\n \n=\n \nNaN\n\n\nhapmap\n[\n1\n,\n \n1\n]\n\n\n\n\n\n\n(true,false)\n\n\n\n\n\nhapmap\n[\n1\n,\n \n1\n]\n \n=\n \n2\n\n\nhapmap\n[\n1\n,\n \n1\n]\n\n\n\n\n\n\n(true,true)\n\n\n\n\n\nSubsetted assignment such as \nhapmap[:, 1] = Nan\n is also valid.\n\n\n\n\nConvert, copy and imputation\n\n\nIn most analyses we convert a whole \nSnpArray\n or slices of it to numeric arrays (matrix of \nminor allele counts\n) for statistical analysis. Keep in mind that the storage of resultant data can be up to 32 fold larger than that of the original \nSnpArray\n. Fortunately, rich collection of data types in \nJulia\n allow us choose one that fits into memory. Below are estimates of memory usage for some common data types with \nn\n persons and \np\n SNPs. Here MAF denotes the \naverage\n minor allele frequencies.\n\n\n\n\nSnpArray\n: $0.25np$ bytes  \n\n\nMatrix{Int8}\n: $np$ bytes  \n\n\nMatrix{Float16}\n: $2np$ bytes  \n\n\nMatrix{Float32}\n: $4np$ bytes  \n\n\nMatrix{Float64}\n: $8np$ bytes  \n\n\nSparseMatrixCSC{Float64,Int64}\n: $16 \\cdot \\text{NNZ} + 8(p+1) \\approx 16np(2\\text{MAF}(1-\\text{MAF})+\\text{MAF}^2) + 8(p+1) = 16np \\cdot \\text{MAF}(2-\\text{MAF}) + 8(p+1)$ bytes. When the average MAF=0.25, this is about $7np$ bytes. When MAF=0.025, this is about $0.8np$ bypes, 10 fold smaller than the \nMatrix{Float64}\n type.  \n\n\nSparseMatrixCSC{Int8,UInt32}\n: $5 \\cdot \\text{NNZ} + 4(p+1) \\approx 5np(2\\text{MAF}(1-\\text{MAF})+\\text{MAF}^2) + 4(p+1) = 5np \\cdot \\text{MAF}(2-\\text{MAF}) + 4(p+1)$ bytes. When the average MAF=0.25, this is about $2.2np$ bytes. When MAF=0.08, this is about $0.8np$ bypes, 10 fold smaller than \nMatrix{Float64}\n type.  \n\n\nTwo \nSparseMatrixCSC{Bool,Int64}\n: $2np \\cdot \\text{MAF} \\cdot 9 + 16(p+1) = 18 np \\cdot \\text{MAF} + 16(p+1)$ bytes. When the average MAF=0.25, this is about $4.5np$ bytes. When MAF=0.045, this is about $0.8np$ bytes, 10 fold smaller than \nMatrix{Float64}\n type.  \n\n\n\n\nTo be concrete, consider 2 typical data sets:   * COPD (GWAS): $n = 6670$ individuals, $p = 630998$ SNPs, average MAF is 0.2454. * GAW19 (sequencing study): $n = 959$ individuals, $p = 8348674$ SNPs, average MAF is 0.085.  \n\n\n\n\n\n\n\n\nData Type\n\n\nCOPD\n\n\nGAW19\n\n\n\n\n\n\n\n\n\n\nSnpArray\n\n\n1.05GB\n\n\n2GB\n\n\n\n\n\n\nMatrix{Float64}\n\n\n33.67GB\n\n\n64.05GB\n\n\n\n\n\n\nSparseMatrixCSC{Float64,Int64}\n\n\n29GB\n\n\n20.82GB\n\n\n\n\n\n\nSparseMatrixCSC{Bool,Int64}\n\n\n18.6GB\n\n\n12.386GB\n\n\n\n\n\n\n\n\nApparently for data sets with a majority of rare variants, converting to sparse matrices saves memory and often brings computational advantages too. In the \nSparseMatrixCSC\n format, the integer type of the row indices \nrowval\n and column pointer \ncolptr\n should have maximal allowable value larger than the number of nonzeros in the matrix. The \nInexactError()\n error encountered during conversion often indicates that the integer type has a too small range. The utility function \nestimatesize\n conveniently estimates memory usage in bytes for the input data type.\n\n\n# estimated memory usage if convert to Matrix{Float64}\n\n\nestimatesize\n(\npeople\n,\n \nsnps\n,\n \nMatrix\n{\nFloat64\n})\n\n\n\n\n\n\n3.6101376e7\n\n\n\n\n\n# convert to Matrix{Float64}\n\n\nhapmapf64\n \n=\n \nconvert\n(\nMatrix\n{\nFloat64\n},\n \nhapmap\n)\n\n\n\n\n\n\n324x13928 Array{Float64,2}:\n 0.0  0.0  2.0  0.0  0.0  0.0  1.0  1.0  \u2026  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  1.0  1.0  1.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  1.0  1.0  1.0  0.0  0.0  2.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  1.0  0.0  0.0  1.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  2.0  0.0  0.0  0.0  \u2026  2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  2.0  0.0  0.0  2.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0  \u2026  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n \u22ee                        \u22ee              \u22f1                      \u22ee            \n 0.0  0.0  1.0  0.0  2.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  2.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  1.0  0.0  0.0  0.0  1.0  \u2026  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  1.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0  \u2026  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  1.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n# actual memory usage of Matrix{Float64}\n\n\nBase\n.\nsummarysize\n(\nhapmapf64\n)\n\n\n\n\n\n\n36101376\n\n\n\n\n\n# average maf of the hapmap3 data set\n\n\nmean\n(\nmaf\n)\n\n\n\n\n\n\n0.222585591341583\n\n\n\n\n\n# estimated memory usage if convert to SparseMatrixCSC{Float32, UInt32} matrix\n\n\nestimatesize\n(\npeople\n,\n \nsnps\n,\n \nSparseMatrixCSC\n{\nFloat32\n,\n \nUInt32\n},\n \nmean\n(\nmaf\n))\n\n\n\n\n\n\n1.4338389205819245e7\n\n\n\n\n\n# convert to SparseMatrixCSC{Float32, UInt32} matrix\n\n\nhapmapf32sp\n \n=\n \nconvert\n(\nSparseMatrixCSC\n{\nFloat32\n,\n \nUInt32\n},\n \nhapmap\n)\n\n\n\n\n\n\n324x13928 sparse matrix with 1614876 Float32 entries:\n    [2    ,     2]  =  1.0\n    [6    ,     2]  =  1.0\n    [15   ,     2]  =  1.0\n    [31   ,     2]  =  1.0\n    [33   ,     2]  =  1.0\n    [35   ,     2]  =  1.0\n    [43   ,     2]  =  1.0\n    [44   ,     2]  =  1.0\n    [50   ,     2]  =  1.0\n    [54   ,     2]  =  1.0\n    \u22ee\n    [135  , 13927]  =  1.0\n    [148  , 13927]  =  1.0\n    [160  , 13927]  =  1.0\n    [164  , 13927]  =  2.0\n    [167  , 13927]  =  1.0\n    [185  , 13927]  =  1.0\n    [266  , 13927]  =  1.0\n    [280  , 13927]  =  1.0\n    [288  , 13927]  =  1.0\n    [118  , 13928]  =  2.0\n    [231  , 13928]  =  2.0\n\n\n\n\n\n# actual memory usage if convert to SparseMatrixCSC{Float32, UInt32} matrix\n\n\nBase\n.\nsummarysize\n(\nhapmapf32sp\n)\n\n\n\n\n\n\n12974764\n\n\n\n\n\nBy default the \nconvert()\n method converts missing genotypes to \nNaN\n.\n\n\n# number of missing genotypes\n\n\ncountnz\n(\nisnan\n(\nhapmap\n)),\n \ncountnz\n(\nisnan\n(\nhapmapf64\n))\n\n\n\n\n\n\n(11894,11894)\n\n\n\n\n\nOne can enforce \ncrude imputation\n by setting the optional argument \nimpute=true\n. Imputation is done by generating two random alleles according to the minor allele frequency. This is a neutral but not an optimal strategy, and users should impute missing genotypes by more advanced methods.\n\n\nhapmapf64impute\n \n=\n \nconvert\n(\nMatrix\n{\nFloat64\n},\n \nhapmap\n;\n \nimpute\n \n=\n \ntrue\n)\n\n\ncountnz\n(\nisnan\n(\nhapmapf64impute\n))\n\n\n\n\n\n\n0\n\n\n\n\n\nBy default \nconvert()\n translates genotypes according to the \nadditive\n SNP model, which essentially counts the number of \nminor allele\n (0, 1 or 2) per genotype. Other SNP models are \ndominant\n and \nrecessive\n, both in terms of the \nminor allele\n. When \nA1\n is the minor allele, genotypes are translated to real number according to\n\n\n\n\n\n\n\n\nGenotype\n\n\nSnpArray\n\n\nmodel=:additive\n\n\nmodel=:dominant\n\n\nmodel=:recessive\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n(false,false)\n\n\n2\n\n\n1\n\n\n1\n\n\n\n\n\n\nA1,A2\n\n\n(false,true)\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A2\n\n\n(true,true)\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\nmissing\n\n\n(true,false)\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\n\n\n\n\n\n\nWhen \nA2\n is the minor allele, genotypes are translated according to\n\n\n\n\n\n\n\n\nGenotype\n\n\nSnpArray\n\n\nmodel=:additive\n\n\nmodel=:dominant\n\n\nmodel=:recessive\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n(false,false)\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\nA1,A2\n\n\n(false,true)\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A2\n\n\n(true,true)\n\n\n2\n\n\n1\n\n\n1\n\n\n\n\n\n\nmissing\n\n\n(true,false)\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\n\n\n\n\n\n\n[\nconvert\n(\nVector\n{\nFloat64\n},\n \nhapmap\n[\n1\n:\n10\n,\n \n5\n];\n \nmodel\n \n=\n \n:\nadditive\n)\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nhapmap\n[\n1\n:\n10\n,\n \n5\n];\n \nmodel\n \n=\n \n:\ndominant\n)\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nhapmap\n[\n1\n:\n10\n,\n \n5\n];\n \nmodel\n \n=\n \n:\nrecessive\n)]\n\n\n\n\n\n\n10x3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 1.0  1.0  0.0\n 1.0  1.0  0.0\n 0.0  0.0  0.0\n 2.0  1.0  1.0\n 2.0  1.0  1.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\nBy default \nconvert()\n does \nnot\n center and scale genotypes. Setting the optional arguments \ncenter=true, scale=true\n centers genotypes at 2MAF and scales them by $[2 \\cdot \\text{MAF} \\cdot (1 - \\text{MAF})]^{-1/2}$. Mono-allelic SNPs (MAF=0) are not scaled.\n\n\n[\nconvert\n(\nVector\n{\nFloat64\n},\n \nhapmap\n[:,\n \n5\n])\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nhapmap\n[:,\n \n5\n];\n \ncenter\n \n=\n \ntrue\n,\n \nscale\n \n=\n \ntrue\n)]\n\n\n\n\n\n\n324x2 Array{Float64,2}:\n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n 1.0   0.167017\n 0.0  -1.25702 \n 2.0   1.59106 \n 2.0   1.59106 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n \u22ee             \n 2.0   1.59106 \n 0.0  -1.25702 \n 1.0   0.167017\n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702\n\n\n\n\n\ncopy!()\n is the in-place version of \nconvert()\n. Options such as GWAS loop over SNPs and perform statistical anlaysis for each SNP. This can be achieved by\n\n\ng\n \n=\n \nzeros\n(\npeople\n)\n\n\nfor\n \nj\n \n=\n \n1\n:\nsnps\n\n    \ncopy!\n(\ng\n,\n \nhapmap\n[:,\n \nj\n];\n \nmodel\n \n=\n \n:\nadditive\n,\n \nimpute\n \n=\n \ntrue\n)\n\n    \n# do statistical anlaysis\n\n\nend\n\n\n\n\n\n\n\n\nEmpirical kinship matrix\n\n\ngrm\n function computes the empirical kinship matrix using either the genetic relationship matrix, \ngrm(A, model=:GRM)\n, or the method of moment method, \ngrm(A, model=:MoM)\n. \n\n\n\n\nNote\n\n\n\n\nMissing genotypes are imputed according to minor allele frequencies on the fly.\n\n\n\n\n\n# GRM using all SNPs\n\n\ngrm\n(\nhapmap\n)\n\n\n\n\n\n\n324x324 Array{Float64,2}:\n 0.566524   0.04431    0.0187306  \u2026  0.0622867  0.0687052  0.0623734\n 0.04431    0.530373   0.0312323     0.0497046  0.0432528  0.0608642\n 0.0187306  0.0312323  0.510791      0.045015   0.0291232  0.0351878\n 0.0463994  0.0356446  0.0277324     0.0574487  0.0632991  0.0576694\n 0.0504432  0.0418174  0.0246636     0.0689248  0.0557189  0.0632692\n 0.0427006  0.0306623  0.0373823  \u2026  0.0679383  0.0547188  0.0627049\n 0.0381117  0.0215367  0.0117409     0.042681   0.0366743  0.0357035\n 0.0395397  0.0369642  0.0206019     0.0555926  0.0526215  0.0637111\n 0.028737   0.0295557  0.0160576     0.0320136  0.044383   0.0362744\n 0.0379938  0.0407265  0.0256978     0.0643465  0.0554608  0.0471915\n 0.0458165  0.0440068  0.0224789  \u2026  0.0561538  0.0642461  0.0584295\n 0.0578648  0.0377148  0.0357752     0.06352    0.0564101  0.0692569\n 0.0347068  0.0423464  0.025328      0.055259   0.067383   0.0614259\n \u22ee                                \u22f1                                 \n 0.063317   0.0534229  0.0368553     0.0832486  0.0831328  0.093519 \n 0.064809   0.0501189  0.0321454     0.0885677  0.0768979  0.0853617\n 0.0651386  0.053962   0.0370123     0.086435   0.080916   0.0819761\n 0.0627899  0.0550938  0.0380069  \u2026  0.0841653  0.0736459  0.0858754\n 0.0604787  0.0534449  0.0351682     0.0757659  0.0705576  0.0785646\n 0.0623749  0.0582096  0.0381049     0.0852801  0.0884385  0.0794518\n 0.0603683  0.0588081  0.0370305     0.079761   0.0814714  0.0782544\n 0.0598038  0.0604263  0.0320275     0.0893622  0.086034   0.0825794\n 0.0634584  0.0608424  0.0315355  \u2026  0.0936972  0.0763907  0.0831321\n 0.0622867  0.0497046  0.045015      0.606873   0.0790143  0.0867932\n 0.0687052  0.0432528  0.0291232     0.0790143  0.583542   0.0794274\n 0.0623734  0.0608642  0.0351878     0.0867932  0.0794274  0.575616\n\n\n\n\n\n# GRM using every other SNP\n\n\ngrm\n(\nsub\n(\nhapmap\n,\n \n:,\n \n1\n:\n2\n:\nsnps\n))\n\n\n\n\n\n\n324x324 Array{Float64,2}:\n 0.555485   0.0414584  0.0265599  \u2026  0.0649969  0.0706832  0.0651222\n 0.0414584  0.545477   0.035331      0.0558445  0.0440697  0.0535371\n 0.0265599  0.035331   0.500768      0.0383132  0.0373413  0.0454816\n 0.0431908  0.0442509  0.0250957     0.0492826  0.0589603  0.0540867\n 0.0504474  0.0467705  0.0245719     0.0650241  0.0548574  0.0630899\n 0.0506486  0.0391991  0.0386068  \u2026  0.074283   0.0601437  0.0509112\n 0.0379701  0.0264693  0.0159633     0.0453982  0.0331826  0.032985 \n 0.0455662  0.0374818  0.0254581     0.0569612  0.053878   0.0662448\n 0.0253964  0.0223143  0.0189219     0.0319043  0.0419019  0.0344454\n 0.0303679  0.0390143  0.0231932     0.0575742  0.0397998  0.0488691\n 0.0471279  0.0490411  0.0198069  \u2026  0.0605351  0.0628944  0.0511443\n 0.059658   0.0481027  0.039431      0.0636518  0.0620679  0.062151 \n 0.0239542  0.0417324  0.0211919     0.0526874  0.0664469  0.0609897\n \u22ee                                \u22f1                                 \n 0.0583416  0.0491196  0.0389251     0.0840045  0.0822214  0.0978664\n 0.0636886  0.0582445  0.0290102     0.0863183  0.0732212  0.0837279\n 0.0666562  0.0518503  0.0369456     0.0814162  0.0784215  0.0923037\n 0.0629366  0.0560442  0.0389387  \u2026  0.0903268  0.0748442  0.0794667\n 0.0612991  0.059333   0.0395798     0.0704755  0.0668915  0.0842222\n 0.0634261  0.0612304  0.0394953     0.0734993  0.0792671  0.086164 \n 0.0611508  0.0621148  0.0306512     0.0831387  0.0885752  0.0803842\n 0.0579779  0.0592217  0.0333789     0.0913713  0.0884812  0.0801725\n 0.0735156  0.0639219  0.0384092  \u2026  0.0981748  0.0720091  0.086251 \n 0.0649969  0.0558445  0.0383132     0.5992     0.0671005  0.0924877\n 0.0706832  0.0440697  0.0373413     0.0671005  0.561654   0.071662 \n 0.0651222  0.0535371  0.0454816     0.0924877  0.071662   0.576829\n\n\n\n\n\n# MoM using all SNPs\n\n\ngrm\n(\nhapmap\n;\n \nmethod\n \n=\n \n:\nMoM\n)\n\n\n\n\n\n\n324x324 Array{Float64,2}:\n 0.539214    0.0347339  0.00320397  \u2026  0.0536283  0.0633117  0.0506761\n 0.0347339   0.518076   0.0148949      0.0422917  0.0392214  0.0502037\n 0.00320397  0.0148949  0.500008       0.033435   0.0212717  0.0206813\n 0.0430002   0.0288295  0.0238697      0.0519751  0.0686257  0.049259 \n 0.0450078   0.0330807  0.0167843      0.0655554  0.0566986  0.0565806\n 0.0323721   0.0211536  0.0271762   \u2026  0.0598871  0.0493771  0.0497313\n 0.0249325   0.0109979  0.00332206     0.0316636  0.030837   0.0248144\n 0.0261134   0.0287114  0.0104074      0.0386309  0.0460706  0.0467791\n 0.0206813   0.025641   0.0143044      0.0297742  0.0484324  0.0304827\n 0.0212717   0.0254048  0.0114703      0.0530379  0.0509122  0.0324902\n 0.0360329   0.0328445  0.00662857  \u2026  0.0497313  0.0557539  0.0502037\n 0.0484324   0.0322541  0.0281209      0.0556358  0.0552816  0.0525655\n 0.0314274   0.0418193  0.0255229      0.0587062  0.0705152  0.0578795\n \u22ee                                  \u22f1                                 \n 0.0420555   0.0417012  0.0267038      0.0713418  0.0792538  0.0816156\n 0.0620127   0.0481962  0.0276486      0.0918894  0.0788995  0.0833869\n 0.0548092   0.0454801  0.0264677      0.0806709  0.0811432  0.0727589\n 0.0447716   0.0421736  0.0246963   \u2026  0.0722865  0.0621308  0.0698066\n 0.0564625   0.0533921  0.0294199      0.0774825  0.0703971  0.074294 \n 0.0524474   0.0542188  0.0314274      0.0788995  0.0858668  0.071578 \n 0.0523293   0.050558   0.0290656      0.0778367  0.0826784  0.0734674\n 0.0483143   0.0528017  0.0210355      0.0824422  0.083505   0.0719322\n 0.0507942   0.0484324  0.0228069   \u2026  0.0885829  0.0738217  0.0693343\n 0.0536283   0.0422917  0.033435       0.561533   0.0805528  0.0760654\n 0.0633117   0.0392214  0.0212717      0.0805528  0.566492   0.06898  \n 0.0506761   0.0502037  0.0206813      0.0760654  0.06898    0.533309\n\n\n\n\n\n\n\nPrincipal components\n\n\nPrincipal compoenent analysis is widely used in genome-wide association analysis (GWAS) for adjusting population substructure. \npca(A, pcs)\n computes the top \npcs\n principal components of a \nSnpArray\n. Each SNP is centered at $2\\text{MAF}$ and scaled by $[2\\text{MAF}(1-\\text{MAF})]^{-1/2}$. The output is  \n\n\n\n\npcscore\n: top \npcs\n eigen-SNPs, or principal scores, in each column  \n\n\npcloading\n: top \npcs\n eigen-vectors, or principal loadings, in each column  \n\n\npcvariance\n: top \npcs\n eigen-values, or principal variances\n\n\n\n\nMissing genotypes are imputed according the minor allele frequencies on the fly. This implies that, in the presence of missing genotypes, running the function on the same \nSnpArray\n twice may produce slightly different answers. For reproducibility, it is a good practice to set the random seed before each function that does imputation on the fly.\n\n\nsrand\n(\n123\n)\n \n# set seed\n\n\npcscore\n,\n \npcloading\n,\n \npcvariance\n \n=\n \npca\n(\nhapmap\n,\n \n3\n)\n\n\n\n\n\n\n(\n324x3 Array{Float64,2}:\n -38.7231  -1.2983     -7.00541  \n -32.6096  -1.21052    -3.3232   \n -23.0215  -0.505397   12.1751   \n -35.692   -2.76103    -2.40055  \n -37.1815  -0.132498   -3.66829  \n -34.9285  -1.11368     6.14167  \n -22.0323  -5.70536     2.02968  \n -30.9994  -2.28269    -0.0893283\n -22.8432  -3.76024     7.97486  \n -32.2024  -0.239253    2.91168  \n -36.344   -0.773184   -5.31525  \n -35.886   -0.807234    0.279053 \n -33.9423  -3.78982     7.35677  \n   \u22ee                             \n -49.1282   0.913683   10.4061   \n -46.9862  -0.9654     -0.435579 \n -48.5334  -1.05076    -0.15223  \n -49.0331   0.379279    5.65431  \n -47.8714  -0.406195   -7.14605  \n -48.2028  -1.41369    -0.564107 \n -46.7128  -3.36643    -4.44341  \n -48.9006  -1.69293     0.0467995\n -48.5574   1.34936    -1.89814  \n -50.2291   0.0865293  -1.94494  \n -48.9263  -2.06102     2.17374  \n -48.8627   0.274894    6.49518  ,\n\n13928x3 Array{Float64,2}:\n  9.66817e-20   7.35949e-19   5.79015e-19\n  0.00143962   -0.0042375    -0.00311816 \n -0.0183601    -0.00512036    0.00322409 \n -0.00956451   -0.004523     -0.00478078 \n  0.0211999    -0.0226285     0.0110026  \n -1.82e-19     -1.35541e-18  -1.07856e-18\n -0.00230269   -0.000231224  -0.00339487 \n -0.0202126    -0.0025855     8.10915e-5 \n  0.00631175   -0.0181213     0.00582407 \n  0.000691273  -0.00158342   -0.0121338  \n -6.34042e-19  -3.71923e-18  -2.90818e-18\n  0.0186933     7.92095e-5    0.00276918 \n -0.0127722     0.00765991    0.0134646  \n  \u22ee                                      \n  0.000732677   0.000506129   0.00241864 \n  0.000632772   0.000487763   0.00243887 \n -0.000604616  -0.000224069  -0.00294191 \n  0.000769648   0.000534368   0.00250158 \n  0.000410429   0.000371501   0.00266287 \n -0.00115497   -0.00172623    0.00106324 \n  0.00051705    0.000728929   0.00249755 \n  0.000652703   0.000748617   0.0023053  \n  0.000643944  -0.000151043   0.00242307 \n -0.00149825   -0.000183435  -0.00454919 \n  0.00313326   -0.00427486   -0.0152038  \n -9.09523e-5   -0.00287777    0.0037855  ,\n\n[1841.3950939952633,225.32365874997188,70.70835685208192])\n\n\n\n\n\nTo use eigen-SNPs for plotting or as covariates in GWAS, we typically scale them by their standard deviations so that they have mean zero and unit variance.\n\n\n# standardize eigen-SNPs before plotting or GWAS\n\n\nscale!\n(\npcscore\n,\n \n1.0\n \n./\n \n\u221a\n(\npcvariance\n))\n\n\nstd\n(\npcscore\n,\n \n1\n)\n\n\n\n\n\n\n1x3 Array{Float64,2}:\n 1.0  1.0  1.0\n\n\n\n\n\nInternally \npca\n converts \nSnpArray\n to the matrix of minor allele counts. The default format is \nMatrix{Float64}\n, which can easily exceed memory limit. Users have several options when the default \nMatrix{Float64}\n cannot fit into memory.  \n\n\n\n\nUse other intermediate matrix types.\n\n\n\n\n# use single precision matrix and display the principal variances\n\n\n# approximately same answer as double precision\n\n\nsrand\n(\n123\n)\n\n\npca\n(\nhapmap\n,\n \n3\n,\n \nMatrix\n{\nFloat32\n})[\n3\n]\n\n\n\n\n\n\n3-element Array{Float32,1}:\n 1841.39  \n  225.324 \n   70.7085\n\n\n\n\n\n\n\nUse subset of SNPs\n\n\n\n\n# principal components using every other SNP capture about half the variance\n\n\nsrand\n(\n123\n)\n\n\npca\n(\nsub\n(\nhapmap\n,\n \n:,\n \n1\n:\n2\n:\nsnps\n),\n \n3\n)[\n3\n]\n\n\n\n\n\n\n3-element Array{Float64,1}:\n 926.622 \n 113.188 \n  36.4866\n\n\n\n\n\n\n\nUse sparse matrix. For large data sets with majority of rare variants, \npca_sp\n is more efficient by first converting \nSnpArray\n to a sparse matrix (default is \nSparseMatrixCSC{Float64, Int64}\n) and then computing principal components using iterative algorithms. \n\n\n\n\n# approximately same answer if we use Float16 sparse matrix\n\n\nsrand\n(\n123\n)\n\n\npca_sp\n(\nhapmap\n,\n \n3\n,\n \nSparseMatrixCSC\n{\nFloat16\n,\n \nUInt32\n})[\n3\n]\n\n\n\n\n\n\n3-element Array{Float64,1}:\n 1841.4   \n  225.31  \n   70.7094\n\n\n\n\n\n# approximately same answer if we use Int8 sparse matrix\n\n\nsrand\n(\n123\n)\n\n\npca_sp\n(\nhapmap\n,\n \n3\n,\n \nSparseMatrixCSC\n{\nInt8\n,\n \nUInt32\n})[\n3\n]\n\n\n\n\n\n\n3-element Array{Float64,1}:\n 1841.4   \n  225.328 \n   70.7119", 
            "title": "SnpArray"
        }, 
        {
            "location": "/man/snparray/#snparray", 
            "text": "SnpArray  is an array of  Tuple{Bool,Bool}  and adopts the same coding as the  Plink binary format . If  A1  and  A2  are the two alleles, the coding rule is       Genotype  SnpArray      A1,A1  (false,false)    A1,A2  (false,true)    A2,A2  (true,true)    missing  (true,false)     The code  (true,false)  is reserved for missing genotype. Otherwise, the bit  true  represents one copy of allele  A2 . In a two-dimensional  SnpArray , each row is a person and each column is a SNP.  For complete genotype data, for example, after imputation, consider using the  HaplotypeArray  type.", 
            "title": "SnpArray"
        }, 
        {
            "location": "/man/snparray/#constructor", 
            "text": "There are various ways to initialize a  SnpArray .     SnpArray  can be initialized from  Plink binary files , say the sample data set hapmap3:   ; ls   - al   hapmap3 .*   -rw-r--r--  1 hzhou3  staff  1128171 Jul 12 04:45 hapmap3.bed\n-rw-r--r--  1 hzhou3  staff   388672 Jul  7 18:09 hapmap3.bim\n-rw-r--r--  1 hzhou3  staff     7136 Jul  7 18:09 hapmap3.fam\n-rw-r--r--  1 hzhou3  staff   332960 Jul  7 18:09 hapmap3.map  using   SnpArrays  hapmap   =   SnpArray ( hapmap3 )   324x13928 SnpArrays.SnpArray{2}:\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (false,true)  (false,true)      (false,true)  (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (false,true)  (true,true)    \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)   \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n \u22ee                                         \u22f1                           \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)  By default, the constructor figures out the number of individuals and SNPs from the  .bim  and  .fam  files.  # rows are people; columns are SNPs  people ,   snps   =   size ( hapmap )   (324,13928)  Alternatively, users can supply keyword arguments  people  and  snps  to the constructor. In this case only the  .bed  file needs to be present.  hapmap   =   SnpArray ( hapmap3 ;   people   =   324 ,   snps   =   13928 )   324x13928 SnpArrays.SnpArray{2}:\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (false,true)  (false,true)      (false,true)  (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (false,true)  (true,true)    \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)   \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n \u22ee                                         \u22f1                           \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)  Internally  SnpArray  stores data as  BitArray s and consumes approximately the same amount of memory as the Plink  bed  file size.  # memory usage, bed file size  Base . summarysize ( hapmap ),   filesize ( hapmap3.bed )   (1128256,1128171)   SnpArray  can be initialized from a matrix of A1 allele counts.   SnpArray ( rand ( 0 : 2 ,   5 ,   3 ))   5x3 SnpArrays.SnpArray{2}:\n (true,true)    (false,false)  (true,true)  \n (false,false)  (true,true)    (false,false)\n (false,true)   (true,true)    (false,true) \n (false,true)   (true,true)    (false,true) \n (false,false)  (false,true)   (false,true)   SnpArray(m, n)  generates an m by n  SnpArray  of all A1 alleles.   s   =   SnpArray ( 5 ,   3 )   5x3 SnpArrays.SnpArray{2}:\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)", 
            "title": "Constructor"
        }, 
        {
            "location": "/man/snparray/#summary-statistics", 
            "text": "summarize  function computes the following summary statistics of a  SnpArray :     maf : minor allele frequencies, taking into account of missingness.    minor_allele : a  BitVector  indicating the minor allele for each SNP.    minor_allele[j]==true  means A1 is the minor allele for SNP j;  minor_allele[j]==false  means A2 is the minor allele for SNP j.    missings_by_snp : number of missing genotypes for each snp.    missings_by_person : number of missing genotypes for each person.     maf ,   minor_allele ,   missings_by_snp ,   missings_by_person   =   summarize ( hapmap )  # minor allele frequencies  maf   1x13928 Array{Float64,2}:\n 0.0  0.0776398  0.324074  0.191589  \u2026  0.00154321  0.0417957  0.00617284  # total number of missing genotypes  sum ( missings_by_snp ),   sum ( missings_by_person )   (11894,11894)  # proportion of missing genotypes  sum ( missings_by_snp )   /   length ( hapmap )   0.0026356890108565393", 
            "title": "Summary statistics"
        }, 
        {
            "location": "/man/snparray/#filtering", 
            "text": "In almost all analyses, SNPs and individuals with low genotyping success rates are ignored. This filtering step is an important tool for removing likely false positives from association testing, as genotyping failure often occurs preferentially in cases or controls, or is correlated with the quantitative trait.  filter(s, min_success_rate_per_snp, min_success_rate_per_person)  does filtering according to the specified success rates for SNPs and people. Default is 0.98 for both.  # filtering SNPs and people to have both success rates above 0.98  snp_idx ,   person_idx   =   filter ( hapmap ,   0.98 ,   0.98 )  # summary statistics of the filtered SnpArray  _ ,   _ ,   missings_by_snp_filtered ,   missings_by_person_filtered   =   summarize ( sub ( hapmap ,   person_idx ,   snp_idx ));   # minimum SNP genotyping success rate after filtering \u2265 0.98  1.0   -   maximum ( missings_by_snp_filtered )   /   length ( missings_by_person_filtered )   0.9813084112149533  # minimum person genotyping success rate after filtering \u2265 0.98  1.0   -   maximum ( missings_by_person_filtered )   /   length ( missings_by_snp_filtered )   0.9818511796733213", 
            "title": "Filtering"
        }, 
        {
            "location": "/man/snparray/#random-genotypes-generation", 
            "text": "randgeno(a1freq)  generates a random genotype according to A1 allele frequency  a1freq .  randgeno ( 0.5 )   (false,true)  randgeno(maf, minor_allele)  generates a random genotype according to minor allele frequency  maf  and whether the minor allele is A1 ( minor_allele==true ) or A2 ( minor_allele==false ).  randgeno ( 0.25 ,   true )   (false,true)  randgeno(n, maf, minor_allele)  generates a vector of random genotypes according to a common minor allele frequency  maf  and the minor allele.  randgeno ( 10 ,   0.25 ,   true )   10-element SnpArrays.SnpArray{1}:\n (true,true)  \n (false,false)\n (true,true)  \n (false,true) \n (false,true) \n (true,true)  \n (true,true)  \n (false,true) \n (false,true) \n (false,true)  randgeno(m, n, maf, minor_allele)  generates a random $m$-by-$n$  SnpArray  according to a vector of minor allele frequencies  maf  and a minor allele indicator vector. The lengths of both vectors should be  n .  # this is a random replicate of the hapmap data  randgeno ( size ( hapmap ),   maf ,   minor_allele )   324x13928 SnpArrays.SnpArray{2}:\n (true,true)  (false,true)  (false,true)   \u2026  (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (false,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (false,true)\n (true,true)  (true,true)   (true,true)    \u2026  (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true) \n (true,true)  (true,true)   (false,false)     (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (false,true)  (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true) \n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true) \n \u22ee                                         \u22f1                            \n (true,true)  (true,true)   (false,false)     (false,true)  (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)    \u2026  (true,true)   (true,true) \n (true,true)  (false,true)  (true,true)       (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)    \u2026  (true,true)   (true,true) \n (true,true)  (true,true)   (false,true)      (true,true)   (true,true) \n (true,true)  (true,true)   (true,true)       (false,true)  (true,true) \n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)", 
            "title": "Random genotypes generation"
        }, 
        {
            "location": "/man/snparray/#subsetting", 
            "text": "Subsetting a  SnpArray  works the same way as subsetting any other arrays.  # genotypes of the 1st person  hapmap [ 1 ,   :]   1x13928 SnpArrays.SnpArray{2}:\n (true,true)  (true,true)  (false,false)  \u2026  (true,true)  (true,true)  # genotypes of the 5th SNP  hapmap [:,   5 ]   324-element SnpArrays.SnpArray{1}:\n (true,true)  \n (true,true)  \n (false,true) \n (false,true) \n (true,true)  \n (false,false)\n (false,false)\n (true,true)  \n (true,true)  \n (true,true)  \n (true,true)  \n (true,true)  \n (false,true) \n \u22ee            \n (false,false)\n (true,true)  \n (false,true) \n (true,true)  \n (true,true)  \n (true,true)  \n (true,true)  \n (true,true)  \n (false,true) \n (true,true)  \n (true,true)  \n (true,true)  # subsetting both persons and SNPs  hapmap [ 1 : 5 ,   5 : 10 ]   5x6 SnpArrays.SnpArray{2}:\n (true,true)   (true,true)  (false,true)  \u2026  (true,true)   (false,true)\n (true,true)   (true,true)  (true,true)      (true,true)   (false,true)\n (false,true)  (true,true)  (true,true)      (false,true)  (true,true) \n (false,true)  (true,true)  (true,true)      (true,true)   (false,true)\n (true,true)   (true,true)  (true,true)      (true,true)   (false,true)  # filter out rare SNPs with MAF   0.05  hapmap [:,   maf   . \u2265   0.05 ]   324x12085 SnpArrays.SnpArray{2}:\n (true,true)   (false,false)  (true,true)   \u2026  (false,true)  (false,true)\n (false,true)  (false,true)   (false,true)     (true,true)   (true,true) \n (true,true)   (false,true)   (false,true)     (true,true)   (true,true) \n (true,true)   (false,true)   (true,true)      (false,true)  (false,true)\n (true,true)   (false,true)   (false,true)     (true,true)   (true,true) \n (false,true)  (true,true)    (true,true)   \u2026  (false,true)  (false,true)\n (true,true)   (true,true)    (true,true)      (true,true)   (true,true) \n (true,true)   (false,false)  (true,true)      (true,true)   (true,true) \n (true,true)   (false,true)   (false,true)     (true,true)   (true,true) \n (true,true)   (false,true)   (true,true)      (false,true)  (false,true)\n (true,true)   (false,true)   (true,true)   \u2026  (true,true)   (true,true) \n (true,true)   (true,true)    (false,true)     (false,true)  (false,true)\n (true,true)   (false,false)  (true,true)      (false,true)  (false,true)\n \u22ee                                          \u22f1                            \n (true,true)   (false,true)   (true,true)      (false,true)  (false,true)\n (true,true)   (false,false)  (true,true)      (false,true)  (false,true)\n (true,true)   (false,false)  (true,true)      (true,true)   (true,true) \n (true,true)   (false,false)  (false,true)  \u2026  (true,true)   (true,true) \n (true,true)   (false,true)   (true,true)      (true,true)   (true,true) \n (true,true)   (true,true)    (false,true)     (false,true)  (false,true)\n (true,true)   (false,true)   (false,true)     (false,true)  (false,true)\n (true,true)   (false,true)   (true,true)      (true,true)   (true,true) \n (true,true)   (false,false)  (true,true)   \u2026  (false,true)  (false,true)\n (true,true)   (false,true)   (false,true)     (false,true)  (false,true)\n (true,true)   (false,false)  (false,true)     (false,true)  (false,true)\n (true,true)   (false,false)  (true,true)      (true,true)   (true,true)  # filter out individuals with genotyping success rate   0.90  hapmap [ missings_by_person   /   people   .   0.1 ,   :]   220x13928 SnpArrays.SnpArray{2}:\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (false,true)  (false,true)      (false,true)  (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)   \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (false,true)  (false,true)   \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n (true,true)  (true,true)   (true,true)       (true,true)   (true,true)\n \u22ee                                         \u22f1                           \n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)  \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)   \u2026  (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,true)      (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)\n (true,true)  (true,true)   (false,false)     (true,true)   (true,true)  sub()  and  slice()  create views of subarray without copying data and improve efficiency in many calculations.  mafcommon ,   =   summarize ( sub ( hapmap ,   :,   maf   . \u2265   0.05 ))  mafcommon   1x12085 Array{Float64,2}:\n 0.0776398  0.324074  0.191589  \u2026  0.310937  0.23913  0.23913  0.23913", 
            "title": "Subsetting"
        }, 
        {
            "location": "/man/snparray/#assignment", 
            "text": "It is possible to assign specific genotypes to a  SnpArray  entry.  hapmap [ 1 ,   1 ]   (true,true)  hapmap [ 1 ,   1 ]   =   ( false ,   true )  hapmap [ 1 ,   1 ]   (false,true)  hapmap [ 1 ,   1 ]   =   NaN  hapmap [ 1 ,   1 ]   (true,false)  hapmap [ 1 ,   1 ]   =   2  hapmap [ 1 ,   1 ]   (true,true)  Subsetted assignment such as  hapmap[:, 1] = Nan  is also valid.", 
            "title": "Assignment"
        }, 
        {
            "location": "/man/snparray/#convert-copy-and-imputation", 
            "text": "In most analyses we convert a whole  SnpArray  or slices of it to numeric arrays (matrix of  minor allele counts ) for statistical analysis. Keep in mind that the storage of resultant data can be up to 32 fold larger than that of the original  SnpArray . Fortunately, rich collection of data types in  Julia  allow us choose one that fits into memory. Below are estimates of memory usage for some common data types with  n  persons and  p  SNPs. Here MAF denotes the  average  minor allele frequencies.   SnpArray : $0.25np$ bytes    Matrix{Int8} : $np$ bytes    Matrix{Float16} : $2np$ bytes    Matrix{Float32} : $4np$ bytes    Matrix{Float64} : $8np$ bytes    SparseMatrixCSC{Float64,Int64} : $16 \\cdot \\text{NNZ} + 8(p+1) \\approx 16np(2\\text{MAF}(1-\\text{MAF})+\\text{MAF}^2) + 8(p+1) = 16np \\cdot \\text{MAF}(2-\\text{MAF}) + 8(p+1)$ bytes. When the average MAF=0.25, this is about $7np$ bytes. When MAF=0.025, this is about $0.8np$ bypes, 10 fold smaller than the  Matrix{Float64}  type.    SparseMatrixCSC{Int8,UInt32} : $5 \\cdot \\text{NNZ} + 4(p+1) \\approx 5np(2\\text{MAF}(1-\\text{MAF})+\\text{MAF}^2) + 4(p+1) = 5np \\cdot \\text{MAF}(2-\\text{MAF}) + 4(p+1)$ bytes. When the average MAF=0.25, this is about $2.2np$ bytes. When MAF=0.08, this is about $0.8np$ bypes, 10 fold smaller than  Matrix{Float64}  type.    Two  SparseMatrixCSC{Bool,Int64} : $2np \\cdot \\text{MAF} \\cdot 9 + 16(p+1) = 18 np \\cdot \\text{MAF} + 16(p+1)$ bytes. When the average MAF=0.25, this is about $4.5np$ bytes. When MAF=0.045, this is about $0.8np$ bytes, 10 fold smaller than  Matrix{Float64}  type.     To be concrete, consider 2 typical data sets:   * COPD (GWAS): $n = 6670$ individuals, $p = 630998$ SNPs, average MAF is 0.2454. * GAW19 (sequencing study): $n = 959$ individuals, $p = 8348674$ SNPs, average MAF is 0.085.       Data Type  COPD  GAW19      SnpArray  1.05GB  2GB    Matrix{Float64}  33.67GB  64.05GB    SparseMatrixCSC{Float64,Int64}  29GB  20.82GB    SparseMatrixCSC{Bool,Int64}  18.6GB  12.386GB     Apparently for data sets with a majority of rare variants, converting to sparse matrices saves memory and often brings computational advantages too. In the  SparseMatrixCSC  format, the integer type of the row indices  rowval  and column pointer  colptr  should have maximal allowable value larger than the number of nonzeros in the matrix. The  InexactError()  error encountered during conversion often indicates that the integer type has a too small range. The utility function  estimatesize  conveniently estimates memory usage in bytes for the input data type.  # estimated memory usage if convert to Matrix{Float64}  estimatesize ( people ,   snps ,   Matrix { Float64 })   3.6101376e7  # convert to Matrix{Float64}  hapmapf64   =   convert ( Matrix { Float64 },   hapmap )   324x13928 Array{Float64,2}:\n 0.0  0.0  2.0  0.0  0.0  0.0  1.0  1.0  \u2026  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  1.0  1.0  1.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  1.0  1.0  1.0  0.0  0.0  2.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  1.0  0.0  0.0  1.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  2.0  0.0  0.0  0.0  \u2026  2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  2.0  0.0  0.0  2.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0  \u2026  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n \u22ee                        \u22ee              \u22f1                      \u22ee            \n 0.0  0.0  1.0  0.0  2.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  2.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  1.0  0.0  0.0  0.0  1.0  \u2026  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  1.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0  \u2026  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  1.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  # actual memory usage of Matrix{Float64}  Base . summarysize ( hapmapf64 )   36101376  # average maf of the hapmap3 data set  mean ( maf )   0.222585591341583  # estimated memory usage if convert to SparseMatrixCSC{Float32, UInt32} matrix  estimatesize ( people ,   snps ,   SparseMatrixCSC { Float32 ,   UInt32 },   mean ( maf ))   1.4338389205819245e7  # convert to SparseMatrixCSC{Float32, UInt32} matrix  hapmapf32sp   =   convert ( SparseMatrixCSC { Float32 ,   UInt32 },   hapmap )   324x13928 sparse matrix with 1614876 Float32 entries:\n    [2    ,     2]  =  1.0\n    [6    ,     2]  =  1.0\n    [15   ,     2]  =  1.0\n    [31   ,     2]  =  1.0\n    [33   ,     2]  =  1.0\n    [35   ,     2]  =  1.0\n    [43   ,     2]  =  1.0\n    [44   ,     2]  =  1.0\n    [50   ,     2]  =  1.0\n    [54   ,     2]  =  1.0\n    \u22ee\n    [135  , 13927]  =  1.0\n    [148  , 13927]  =  1.0\n    [160  , 13927]  =  1.0\n    [164  , 13927]  =  2.0\n    [167  , 13927]  =  1.0\n    [185  , 13927]  =  1.0\n    [266  , 13927]  =  1.0\n    [280  , 13927]  =  1.0\n    [288  , 13927]  =  1.0\n    [118  , 13928]  =  2.0\n    [231  , 13928]  =  2.0  # actual memory usage if convert to SparseMatrixCSC{Float32, UInt32} matrix  Base . summarysize ( hapmapf32sp )   12974764  By default the  convert()  method converts missing genotypes to  NaN .  # number of missing genotypes  countnz ( isnan ( hapmap )),   countnz ( isnan ( hapmapf64 ))   (11894,11894)  One can enforce  crude imputation  by setting the optional argument  impute=true . Imputation is done by generating two random alleles according to the minor allele frequency. This is a neutral but not an optimal strategy, and users should impute missing genotypes by more advanced methods.  hapmapf64impute   =   convert ( Matrix { Float64 },   hapmap ;   impute   =   true )  countnz ( isnan ( hapmapf64impute ))   0  By default  convert()  translates genotypes according to the  additive  SNP model, which essentially counts the number of  minor allele  (0, 1 or 2) per genotype. Other SNP models are  dominant  and  recessive , both in terms of the  minor allele . When  A1  is the minor allele, genotypes are translated to real number according to     Genotype  SnpArray  model=:additive  model=:dominant  model=:recessive      A1,A1  (false,false)  2  1  1    A1,A2  (false,true)  1  1  0    A2,A2  (true,true)  0  0  0    missing  (true,false)  NaN  NaN  NaN     When  A2  is the minor allele, genotypes are translated according to     Genotype  SnpArray  model=:additive  model=:dominant  model=:recessive      A1,A1  (false,false)  0  0  0    A1,A2  (false,true)  1  1  0    A2,A2  (true,true)  2  1  1    missing  (true,false)  NaN  NaN  NaN     [ convert ( Vector { Float64 },   hapmap [ 1 : 10 ,   5 ];   model   =   : additive )   convert ( Vector { Float64 },   hapmap [ 1 : 10 ,   5 ];   model   =   : dominant )   convert ( Vector { Float64 },   hapmap [ 1 : 10 ,   5 ];   model   =   : recessive )]   10x3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 1.0  1.0  0.0\n 1.0  1.0  0.0\n 0.0  0.0  0.0\n 2.0  1.0  1.0\n 2.0  1.0  1.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0  By default  convert()  does  not  center and scale genotypes. Setting the optional arguments  center=true, scale=true  centers genotypes at 2MAF and scales them by $[2 \\cdot \\text{MAF} \\cdot (1 - \\text{MAF})]^{-1/2}$. Mono-allelic SNPs (MAF=0) are not scaled.  [ convert ( Vector { Float64 },   hapmap [:,   5 ])   convert ( Vector { Float64 },   hapmap [:,   5 ];   center   =   true ,   scale   =   true )]   324x2 Array{Float64,2}:\n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n 1.0   0.167017\n 0.0  -1.25702 \n 2.0   1.59106 \n 2.0   1.59106 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n \u22ee             \n 2.0   1.59106 \n 0.0  -1.25702 \n 1.0   0.167017\n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702  copy!()  is the in-place version of  convert() . Options such as GWAS loop over SNPs and perform statistical anlaysis for each SNP. This can be achieved by  g   =   zeros ( people )  for   j   =   1 : snps \n     copy! ( g ,   hapmap [:,   j ];   model   =   : additive ,   impute   =   true ) \n     # do statistical anlaysis  end", 
            "title": "Convert, copy and imputation"
        }, 
        {
            "location": "/man/snparray/#empirical-kinship-matrix", 
            "text": "grm  function computes the empirical kinship matrix using either the genetic relationship matrix,  grm(A, model=:GRM) , or the method of moment method,  grm(A, model=:MoM) .    Note   Missing genotypes are imputed according to minor allele frequencies on the fly.  # GRM using all SNPs  grm ( hapmap )   324x324 Array{Float64,2}:\n 0.566524   0.04431    0.0187306  \u2026  0.0622867  0.0687052  0.0623734\n 0.04431    0.530373   0.0312323     0.0497046  0.0432528  0.0608642\n 0.0187306  0.0312323  0.510791      0.045015   0.0291232  0.0351878\n 0.0463994  0.0356446  0.0277324     0.0574487  0.0632991  0.0576694\n 0.0504432  0.0418174  0.0246636     0.0689248  0.0557189  0.0632692\n 0.0427006  0.0306623  0.0373823  \u2026  0.0679383  0.0547188  0.0627049\n 0.0381117  0.0215367  0.0117409     0.042681   0.0366743  0.0357035\n 0.0395397  0.0369642  0.0206019     0.0555926  0.0526215  0.0637111\n 0.028737   0.0295557  0.0160576     0.0320136  0.044383   0.0362744\n 0.0379938  0.0407265  0.0256978     0.0643465  0.0554608  0.0471915\n 0.0458165  0.0440068  0.0224789  \u2026  0.0561538  0.0642461  0.0584295\n 0.0578648  0.0377148  0.0357752     0.06352    0.0564101  0.0692569\n 0.0347068  0.0423464  0.025328      0.055259   0.067383   0.0614259\n \u22ee                                \u22f1                                 \n 0.063317   0.0534229  0.0368553     0.0832486  0.0831328  0.093519 \n 0.064809   0.0501189  0.0321454     0.0885677  0.0768979  0.0853617\n 0.0651386  0.053962   0.0370123     0.086435   0.080916   0.0819761\n 0.0627899  0.0550938  0.0380069  \u2026  0.0841653  0.0736459  0.0858754\n 0.0604787  0.0534449  0.0351682     0.0757659  0.0705576  0.0785646\n 0.0623749  0.0582096  0.0381049     0.0852801  0.0884385  0.0794518\n 0.0603683  0.0588081  0.0370305     0.079761   0.0814714  0.0782544\n 0.0598038  0.0604263  0.0320275     0.0893622  0.086034   0.0825794\n 0.0634584  0.0608424  0.0315355  \u2026  0.0936972  0.0763907  0.0831321\n 0.0622867  0.0497046  0.045015      0.606873   0.0790143  0.0867932\n 0.0687052  0.0432528  0.0291232     0.0790143  0.583542   0.0794274\n 0.0623734  0.0608642  0.0351878     0.0867932  0.0794274  0.575616  # GRM using every other SNP  grm ( sub ( hapmap ,   :,   1 : 2 : snps ))   324x324 Array{Float64,2}:\n 0.555485   0.0414584  0.0265599  \u2026  0.0649969  0.0706832  0.0651222\n 0.0414584  0.545477   0.035331      0.0558445  0.0440697  0.0535371\n 0.0265599  0.035331   0.500768      0.0383132  0.0373413  0.0454816\n 0.0431908  0.0442509  0.0250957     0.0492826  0.0589603  0.0540867\n 0.0504474  0.0467705  0.0245719     0.0650241  0.0548574  0.0630899\n 0.0506486  0.0391991  0.0386068  \u2026  0.074283   0.0601437  0.0509112\n 0.0379701  0.0264693  0.0159633     0.0453982  0.0331826  0.032985 \n 0.0455662  0.0374818  0.0254581     0.0569612  0.053878   0.0662448\n 0.0253964  0.0223143  0.0189219     0.0319043  0.0419019  0.0344454\n 0.0303679  0.0390143  0.0231932     0.0575742  0.0397998  0.0488691\n 0.0471279  0.0490411  0.0198069  \u2026  0.0605351  0.0628944  0.0511443\n 0.059658   0.0481027  0.039431      0.0636518  0.0620679  0.062151 \n 0.0239542  0.0417324  0.0211919     0.0526874  0.0664469  0.0609897\n \u22ee                                \u22f1                                 \n 0.0583416  0.0491196  0.0389251     0.0840045  0.0822214  0.0978664\n 0.0636886  0.0582445  0.0290102     0.0863183  0.0732212  0.0837279\n 0.0666562  0.0518503  0.0369456     0.0814162  0.0784215  0.0923037\n 0.0629366  0.0560442  0.0389387  \u2026  0.0903268  0.0748442  0.0794667\n 0.0612991  0.059333   0.0395798     0.0704755  0.0668915  0.0842222\n 0.0634261  0.0612304  0.0394953     0.0734993  0.0792671  0.086164 \n 0.0611508  0.0621148  0.0306512     0.0831387  0.0885752  0.0803842\n 0.0579779  0.0592217  0.0333789     0.0913713  0.0884812  0.0801725\n 0.0735156  0.0639219  0.0384092  \u2026  0.0981748  0.0720091  0.086251 \n 0.0649969  0.0558445  0.0383132     0.5992     0.0671005  0.0924877\n 0.0706832  0.0440697  0.0373413     0.0671005  0.561654   0.071662 \n 0.0651222  0.0535371  0.0454816     0.0924877  0.071662   0.576829  # MoM using all SNPs  grm ( hapmap ;   method   =   : MoM )   324x324 Array{Float64,2}:\n 0.539214    0.0347339  0.00320397  \u2026  0.0536283  0.0633117  0.0506761\n 0.0347339   0.518076   0.0148949      0.0422917  0.0392214  0.0502037\n 0.00320397  0.0148949  0.500008       0.033435   0.0212717  0.0206813\n 0.0430002   0.0288295  0.0238697      0.0519751  0.0686257  0.049259 \n 0.0450078   0.0330807  0.0167843      0.0655554  0.0566986  0.0565806\n 0.0323721   0.0211536  0.0271762   \u2026  0.0598871  0.0493771  0.0497313\n 0.0249325   0.0109979  0.00332206     0.0316636  0.030837   0.0248144\n 0.0261134   0.0287114  0.0104074      0.0386309  0.0460706  0.0467791\n 0.0206813   0.025641   0.0143044      0.0297742  0.0484324  0.0304827\n 0.0212717   0.0254048  0.0114703      0.0530379  0.0509122  0.0324902\n 0.0360329   0.0328445  0.00662857  \u2026  0.0497313  0.0557539  0.0502037\n 0.0484324   0.0322541  0.0281209      0.0556358  0.0552816  0.0525655\n 0.0314274   0.0418193  0.0255229      0.0587062  0.0705152  0.0578795\n \u22ee                                  \u22f1                                 \n 0.0420555   0.0417012  0.0267038      0.0713418  0.0792538  0.0816156\n 0.0620127   0.0481962  0.0276486      0.0918894  0.0788995  0.0833869\n 0.0548092   0.0454801  0.0264677      0.0806709  0.0811432  0.0727589\n 0.0447716   0.0421736  0.0246963   \u2026  0.0722865  0.0621308  0.0698066\n 0.0564625   0.0533921  0.0294199      0.0774825  0.0703971  0.074294 \n 0.0524474   0.0542188  0.0314274      0.0788995  0.0858668  0.071578 \n 0.0523293   0.050558   0.0290656      0.0778367  0.0826784  0.0734674\n 0.0483143   0.0528017  0.0210355      0.0824422  0.083505   0.0719322\n 0.0507942   0.0484324  0.0228069   \u2026  0.0885829  0.0738217  0.0693343\n 0.0536283   0.0422917  0.033435       0.561533   0.0805528  0.0760654\n 0.0633117   0.0392214  0.0212717      0.0805528  0.566492   0.06898  \n 0.0506761   0.0502037  0.0206813      0.0760654  0.06898    0.533309", 
            "title": "Empirical kinship matrix"
        }, 
        {
            "location": "/man/snparray/#principal-components", 
            "text": "Principal compoenent analysis is widely used in genome-wide association analysis (GWAS) for adjusting population substructure.  pca(A, pcs)  computes the top  pcs  principal components of a  SnpArray . Each SNP is centered at $2\\text{MAF}$ and scaled by $[2\\text{MAF}(1-\\text{MAF})]^{-1/2}$. The output is     pcscore : top  pcs  eigen-SNPs, or principal scores, in each column    pcloading : top  pcs  eigen-vectors, or principal loadings, in each column    pcvariance : top  pcs  eigen-values, or principal variances   Missing genotypes are imputed according the minor allele frequencies on the fly. This implies that, in the presence of missing genotypes, running the function on the same  SnpArray  twice may produce slightly different answers. For reproducibility, it is a good practice to set the random seed before each function that does imputation on the fly.  srand ( 123 )   # set seed  pcscore ,   pcloading ,   pcvariance   =   pca ( hapmap ,   3 )   (\n324x3 Array{Float64,2}:\n -38.7231  -1.2983     -7.00541  \n -32.6096  -1.21052    -3.3232   \n -23.0215  -0.505397   12.1751   \n -35.692   -2.76103    -2.40055  \n -37.1815  -0.132498   -3.66829  \n -34.9285  -1.11368     6.14167  \n -22.0323  -5.70536     2.02968  \n -30.9994  -2.28269    -0.0893283\n -22.8432  -3.76024     7.97486  \n -32.2024  -0.239253    2.91168  \n -36.344   -0.773184   -5.31525  \n -35.886   -0.807234    0.279053 \n -33.9423  -3.78982     7.35677  \n   \u22ee                             \n -49.1282   0.913683   10.4061   \n -46.9862  -0.9654     -0.435579 \n -48.5334  -1.05076    -0.15223  \n -49.0331   0.379279    5.65431  \n -47.8714  -0.406195   -7.14605  \n -48.2028  -1.41369    -0.564107 \n -46.7128  -3.36643    -4.44341  \n -48.9006  -1.69293     0.0467995\n -48.5574   1.34936    -1.89814  \n -50.2291   0.0865293  -1.94494  \n -48.9263  -2.06102     2.17374  \n -48.8627   0.274894    6.49518  ,\n\n13928x3 Array{Float64,2}:\n  9.66817e-20   7.35949e-19   5.79015e-19\n  0.00143962   -0.0042375    -0.00311816 \n -0.0183601    -0.00512036    0.00322409 \n -0.00956451   -0.004523     -0.00478078 \n  0.0211999    -0.0226285     0.0110026  \n -1.82e-19     -1.35541e-18  -1.07856e-18\n -0.00230269   -0.000231224  -0.00339487 \n -0.0202126    -0.0025855     8.10915e-5 \n  0.00631175   -0.0181213     0.00582407 \n  0.000691273  -0.00158342   -0.0121338  \n -6.34042e-19  -3.71923e-18  -2.90818e-18\n  0.0186933     7.92095e-5    0.00276918 \n -0.0127722     0.00765991    0.0134646  \n  \u22ee                                      \n  0.000732677   0.000506129   0.00241864 \n  0.000632772   0.000487763   0.00243887 \n -0.000604616  -0.000224069  -0.00294191 \n  0.000769648   0.000534368   0.00250158 \n  0.000410429   0.000371501   0.00266287 \n -0.00115497   -0.00172623    0.00106324 \n  0.00051705    0.000728929   0.00249755 \n  0.000652703   0.000748617   0.0023053  \n  0.000643944  -0.000151043   0.00242307 \n -0.00149825   -0.000183435  -0.00454919 \n  0.00313326   -0.00427486   -0.0152038  \n -9.09523e-5   -0.00287777    0.0037855  ,\n\n[1841.3950939952633,225.32365874997188,70.70835685208192])  To use eigen-SNPs for plotting or as covariates in GWAS, we typically scale them by their standard deviations so that they have mean zero and unit variance.  # standardize eigen-SNPs before plotting or GWAS  scale! ( pcscore ,   1.0   ./   \u221a ( pcvariance ))  std ( pcscore ,   1 )   1x3 Array{Float64,2}:\n 1.0  1.0  1.0  Internally  pca  converts  SnpArray  to the matrix of minor allele counts. The default format is  Matrix{Float64} , which can easily exceed memory limit. Users have several options when the default  Matrix{Float64}  cannot fit into memory.     Use other intermediate matrix types.   # use single precision matrix and display the principal variances  # approximately same answer as double precision  srand ( 123 )  pca ( hapmap ,   3 ,   Matrix { Float32 })[ 3 ]   3-element Array{Float32,1}:\n 1841.39  \n  225.324 \n   70.7085   Use subset of SNPs   # principal components using every other SNP capture about half the variance  srand ( 123 )  pca ( sub ( hapmap ,   :,   1 : 2 : snps ),   3 )[ 3 ]   3-element Array{Float64,1}:\n 926.622 \n 113.188 \n  36.4866   Use sparse matrix. For large data sets with majority of rare variants,  pca_sp  is more efficient by first converting  SnpArray  to a sparse matrix (default is  SparseMatrixCSC{Float64, Int64} ) and then computing principal components using iterative algorithms.    # approximately same answer if we use Float16 sparse matrix  srand ( 123 )  pca_sp ( hapmap ,   3 ,   SparseMatrixCSC { Float16 ,   UInt32 })[ 3 ]   3-element Array{Float64,1}:\n 1841.4   \n  225.31  \n   70.7094  # approximately same answer if we use Int8 sparse matrix  srand ( 123 )  pca_sp ( hapmap ,   3 ,   SparseMatrixCSC { Int8 ,   UInt32 })[ 3 ]   3-element Array{Float64,1}:\n 1841.4   \n  225.328 \n   70.7119", 
            "title": "Principal components"
        }, 
        {
            "location": "/man/snpdata/", 
            "text": "SnpData\n\n\nSnpData\n stores all SNP information besides genotypes. We initialize \nSnpData\n from Plink binary files. Note all three Plink files \n.bed\n, \n.bim\n and \n.fam\n need to be present.\n\n\nusing\n \nSnpArrays\n\n\nhapmap_snpdata\n \n=\n \nSnpData\n(\nhapmap3\n)\n\n\nfieldnames\n(\nhapmap_snpdata\n)\n\n\n\n\n\n\n14-element Array{Symbol,1}:\n :people             \n :snps               \n :personid           \n :snpid              \n :chromosome         \n :genetic_distance   \n :basepairs          \n :allele1            \n :allele2            \n :maf                \n :minor_allele       \n :snpmatrix          \n :missings_per_person\n :missings_per_snp\n\n\n\n\n\nhapmap_snpdata\n.\nsnpid\n[\n1\n:\n10\n]\n\n\n\n\n\n\n10-element Array{AbstractString,1}:\n \nrs10458597\n\n \nrs12562034\n\n \nrs2710875\n \n \nrs11260566\n\n \nrs1312568\n \n \nrs35154105\n\n \nrs16824508\n\n \nrs2678939\n \n \nrs7553178\n \n \nrs13376356\n\n\n\n\n\n\nhapmap_snpdata\n.\npersonid\n[\n1\n:\n10\n]\n\n\n\n\n\n\n10-element Array{AbstractString,1}:\n \nNA19916\n\n \nNA19835\n\n \nNA20282\n\n \nNA19703\n\n \nNA19901\n\n \nNA19908\n\n \nNA19914\n\n \nNA20287\n\n \nNA19713\n\n \nNA19904\n\n\n\n\n\n\nTo write \nSnpData\n to Plink \nbed\n and \nbim\n files, we use \nwriteplink(filename, snpdata)\n.\n\n\n#writeplink(filename, hapmap_snpdata)", 
            "title": "SnpData"
        }, 
        {
            "location": "/man/snpdata/#snpdata", 
            "text": "SnpData  stores all SNP information besides genotypes. We initialize  SnpData  from Plink binary files. Note all three Plink files  .bed ,  .bim  and  .fam  need to be present.  using   SnpArrays  hapmap_snpdata   =   SnpData ( hapmap3 )  fieldnames ( hapmap_snpdata )   14-element Array{Symbol,1}:\n :people             \n :snps               \n :personid           \n :snpid              \n :chromosome         \n :genetic_distance   \n :basepairs          \n :allele1            \n :allele2            \n :maf                \n :minor_allele       \n :snpmatrix          \n :missings_per_person\n :missings_per_snp  hapmap_snpdata . snpid [ 1 : 10 ]   10-element Array{AbstractString,1}:\n  rs10458597 \n  rs12562034 \n  rs2710875  \n  rs11260566 \n  rs1312568  \n  rs35154105 \n  rs16824508 \n  rs2678939  \n  rs7553178  \n  rs13376356   hapmap_snpdata . personid [ 1 : 10 ]   10-element Array{AbstractString,1}:\n  NA19916 \n  NA19835 \n  NA20282 \n  NA19703 \n  NA19901 \n  NA19908 \n  NA19914 \n  NA20287 \n  NA19713 \n  NA19904   To write  SnpData  to Plink  bed  and  bim  files, we use  writeplink(filename, snpdata) .  #writeplink(filename, hapmap_snpdata)", 
            "title": "SnpData"
        }, 
        {
            "location": "/man/haplotypearray/", 
            "text": "HaplotypeArray\n\n\nThe \nHaplotypeArray\n type is similar to \nSnpArray\n, but with two key differences:  \n\n\n\n\nThe two alleles are ordered, therefore (A1, A2) is different from (A2, A1);  \n\n\nThe code \n(true,false)\n means the genotype (A2, A1), instead of the missing genotype in \nSnpArray\n.  \n\n\n\n\n\n\n\n\n\n\nGenotype\n\n\nHaplotypeArray\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n(false,false)\n\n\n\n\n\n\nA1,A2\n\n\n(false,true)\n\n\n\n\n\n\nA2,A1\n\n\n(true,false)\n\n\n\n\n\n\nA2,A2\n\n\n(true,true)\n\n\n\n\n\n\n\n\nEach bit \ntrue\n in \nHaplotypeArray\n indicates a copy of the A2 allele. \n\n\n\n\nConstructor\n\n\nThere are various ways to initialize a \nHaplotypeArray\n.  \n\n\n\n\nHaplotypeArray\n can be intialized from two \nBitArray\ns. Each \nBitArray\n indicates an A2 allele copy in the first and second positions respectively.\n\n\n\n\nusing\n \nSnpArrays\n\n\nh\n \n=\n \nHaplotypeArray\n(\nbitrand\n(\n5\n,\n \n3\n),\n \nbitrand\n(\n5\n,\n \n3\n))\n\n\n\n\n\n\n5x3 SnpArrays.HaplotypeArray{2}:\n (true,true)    (false,false)  (true,false)\n (true,true)    (false,false)  (true,false)\n (true,false)   (true,false)   (true,false)\n (true,false)   (false,false)  (true,false)\n (false,false)  (false,true)   (true,true)\n\n\n\n\n\n\n\nHaplotypeArray\n can be intialized from a \nSnpArray\n.\n\n\n\n\ns\n \n=\n \nSnpArray\n(\nbitrand\n(\n5\n,\n \n3\n),\n \nbitrand\n(\n5\n,\n \n3\n))\n\n\nh\n \n=\n \nHaplotypeArray\n(\ns\n)\n\n\n\n\n\n\n5x3 SnpArrays.HaplotypeArray{2}:\n (true,false)  (true,false)   (true,true)  \n (true,false)  (true,true)    (true,false) \n (false,true)  (false,true)   (true,true)  \n (true,false)  (false,false)  (false,false)\n (true,false)  (false,true)   (true,true)\n\n\n\n\n\nThis constructor does \nnot\n copy data from \nSnpArray\n. Therefore both \nh\n and \ns\n points to the same patch of memory. Only the interpretation of \n(true, false)\n changes.\n\n\nisnan\n(\ns\n)\n\n\n\n\n\n\n5x3 BitArray{2}:\n  true   true  false\n  true  false   true\n false  false  false\n  true  false  false\n  true  false  false\n\n\n\n\n\nisnan\n(\nh\n)\n\n\n\n\n\n\n5x3 BitArray{2}:\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n\n\n\n\n\nChanges to \nh\n also effect \ns\n.\n\n\nh\n[\nh\n \n.==\n \n(\ntrue\n,\n \nfalse\n)]\n \n=\n \n(\ntrue\n,\n \ntrue\n)\n\n\nisnan\n(\ns\n)\n\n\n\n\n\n\n5x3 BitArray{2}:\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n\n\n\n\n\n\n\nHaplotypeArray(m, n)\n generates an m by n \nHaplotypeArray\n of all A1 alleles.\n\n\n\n\nHaplotypeArray\n(\n5\n,\n \n3\n)\n\n\n\n\n\n\n5x3 SnpArrays.HaplotypeArray{2}:\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n\n\n\n\n\n\n\nSummary statistics\n\n\nsummarize\n when applied to a \nHaplotypeArray\n only computes  \n\n\n\n\nmaf\n: minor allele frequencies, taking into account of missingness.  \n\n\nminor_allele\n: a \nBitVector\n indicating the minor allele for each SNP.   \nminor_allele[j]==true\n means A1 is the minor allele for SNP j; \nminor_allele[j]==false\n means A2 is the minor allele for SNP j.  \n\n\n\n\nmaf\n,\n \nminor_allele\n \n=\n \nsummarize\n(\nh\n)\n\n\n\n\n\n\n([0.09999999999999998,0.4,0.19999999999999996],Bool[true,true,true])\n\n\n\n\n\n\n\nSubsetting and assignment\n\n\nSubsetting and assignment work the same as \nSnpArray\n.\n\n\n\n\nCopy and convert\n\n\nCopying or converting a \nHaplotypeArray\n or slices of it to numeric arrays of \nminor allele counts\n is similar to \nSnpArray\n with the exception there are no missing genotypes in \nHaplotypeArray\n. So the keyword \nimpute\n is not relevant anymore.\n\n\n# convert to Matrix{Float64}\n\n\nh_f64\n \n=\n \nconvert\n(\nMatrix\n{\nFloat64\n},\n \nh\n)\n\n\n\n\n\n\n5x3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 1.0  1.0  0.0\n 0.0  2.0  2.0\n 0.0  1.0  0.0\n\n\n\n\n\nBy default \nconvert\n translates genotypes according to the \nadditive\n SNP model, which essentially counts the number of \nminor allele\n (0, 1 or 2) per genotype. Other SNP models are \ndominant\n and \nrecessive\n, both in terms of the \nminor allele\n. When \nA1\n is the minor allele, genotypes are translated to real number according to\n\n\n\n\n\n\n\n\nGenotype\n\n\nHaplotypeArray\n\n\nmodel=:additive\n\n\nmodel=:dominant\n\n\nmodel=:recessive\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n00\n\n\n2\n\n\n1\n\n\n1\n\n\n\n\n\n\nA1,A2\n\n\n01\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A1\n\n\n10\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A2\n\n\n11\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\nWhen \nA2\n is the minor allele, genotypes are translated according to\n\n\n\n\n\n\n\n\nGenotype\n\n\nHaplotypeArray\n\n\nmodel=:additive\n\n\nmodel=:dominant\n\n\nmodel=:recessive\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n00\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\nA1,A2\n\n\n01\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A1\n\n\n01\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A2\n\n\n11\n\n\n2\n\n\n1\n\n\n1\n\n\n\n\n\n\n\n\n[\nconvert\n(\nVector\n{\nFloat64\n},\n \nh\n[\n1\n:\n5\n,\n \n3\n];\n \nmodel\n \n=\n \n:\nadditive\n)\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nh\n[\n1\n:\n5\n,\n \n3\n];\n \nmodel\n \n=\n \n:\ndominant\n)\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nh\n[\n1\n:\n5\n,\n \n3\n];\n \nmodel\n \n=\n \n:\nrecessive\n)]\n\n\n\n\n\n\n5x3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 2.0  1.0  1.0\n 0.0  0.0  0.0\n\n\n\n\n\nBy default \nconvert\n does \nnot\n center and scale genotypes. Setting the optional arguments \ncenter=true, scale=true\n centers genotypes at 2MAF and scales them by $[2 \\cdot \\text{MAF} \\cdot (1 - \\text{MAF})]^{-1/2}$. Mono-allelic SNPs (MAF=0) are not scaled.\n\n\n[\nconvert\n(\nVector\n{\nFloat64\n},\n \nh\n[:,\n \n3\n])\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nh\n[:,\n \n3\n];\n \ncenter\n \n=\n \ntrue\n,\n \nscale\n \n=\n \ntrue\n)]\n\n\n\n\n\n\n5x2 Array{Float64,2}:\n 0.0  -0.707107\n 0.0  -0.707107\n 0.0  -0.707107\n 2.0   2.82843 \n 0.0  -0.707107\n\n\n\n\n\ncopy!\n is the in-place version of \nconvert()\n. Options such as GWAS loop over SNPs and perform statistical anlaysis for each SNP. This can be achieved by\n\n\ng\n \n=\n \nzeros\n(\nsize\n(\nh\n,\n \n1\n))\n\n\nfor\n \nj\n \n=\n \n1\n:\nsize\n(\nh\n,\n \n2\n)\n\n    \ncopy!\n(\ng\n,\n \nh\n[:,\n \nj\n];\n \nmodel\n \n=\n \n:\nadditive\n)\n\n    \n# do statistical anlaysis\n\n\nend", 
            "title": "HaplotypeArray"
        }, 
        {
            "location": "/man/haplotypearray/#haplotypearray", 
            "text": "The  HaplotypeArray  type is similar to  SnpArray , but with two key differences:     The two alleles are ordered, therefore (A1, A2) is different from (A2, A1);    The code  (true,false)  means the genotype (A2, A1), instead of the missing genotype in  SnpArray .        Genotype  HaplotypeArray      A1,A1  (false,false)    A1,A2  (false,true)    A2,A1  (true,false)    A2,A2  (true,true)     Each bit  true  in  HaplotypeArray  indicates a copy of the A2 allele.", 
            "title": "HaplotypeArray"
        }, 
        {
            "location": "/man/haplotypearray/#constructor", 
            "text": "There are various ways to initialize a  HaplotypeArray .     HaplotypeArray  can be intialized from two  BitArray s. Each  BitArray  indicates an A2 allele copy in the first and second positions respectively.   using   SnpArrays  h   =   HaplotypeArray ( bitrand ( 5 ,   3 ),   bitrand ( 5 ,   3 ))   5x3 SnpArrays.HaplotypeArray{2}:\n (true,true)    (false,false)  (true,false)\n (true,true)    (false,false)  (true,false)\n (true,false)   (true,false)   (true,false)\n (true,false)   (false,false)  (true,false)\n (false,false)  (false,true)   (true,true)   HaplotypeArray  can be intialized from a  SnpArray .   s   =   SnpArray ( bitrand ( 5 ,   3 ),   bitrand ( 5 ,   3 ))  h   =   HaplotypeArray ( s )   5x3 SnpArrays.HaplotypeArray{2}:\n (true,false)  (true,false)   (true,true)  \n (true,false)  (true,true)    (true,false) \n (false,true)  (false,true)   (true,true)  \n (true,false)  (false,false)  (false,false)\n (true,false)  (false,true)   (true,true)  This constructor does  not  copy data from  SnpArray . Therefore both  h  and  s  points to the same patch of memory. Only the interpretation of  (true, false)  changes.  isnan ( s )   5x3 BitArray{2}:\n  true   true  false\n  true  false   true\n false  false  false\n  true  false  false\n  true  false  false  isnan ( h )   5x3 BitArray{2}:\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n false  false  false  Changes to  h  also effect  s .  h [ h   .==   ( true ,   false )]   =   ( true ,   true )  isnan ( s )   5x3 BitArray{2}:\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n false  false  false   HaplotypeArray(m, n)  generates an m by n  HaplotypeArray  of all A1 alleles.   HaplotypeArray ( 5 ,   3 )   5x3 SnpArrays.HaplotypeArray{2}:\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)\n (false,false)  (false,false)  (false,false)", 
            "title": "Constructor"
        }, 
        {
            "location": "/man/haplotypearray/#summary-statistics", 
            "text": "summarize  when applied to a  HaplotypeArray  only computes     maf : minor allele frequencies, taking into account of missingness.    minor_allele : a  BitVector  indicating the minor allele for each SNP.    minor_allele[j]==true  means A1 is the minor allele for SNP j;  minor_allele[j]==false  means A2 is the minor allele for SNP j.     maf ,   minor_allele   =   summarize ( h )   ([0.09999999999999998,0.4,0.19999999999999996],Bool[true,true,true])", 
            "title": "Summary statistics"
        }, 
        {
            "location": "/man/haplotypearray/#subsetting-and-assignment", 
            "text": "Subsetting and assignment work the same as  SnpArray .", 
            "title": "Subsetting and assignment"
        }, 
        {
            "location": "/man/haplotypearray/#copy-and-convert", 
            "text": "Copying or converting a  HaplotypeArray  or slices of it to numeric arrays of  minor allele counts  is similar to  SnpArray  with the exception there are no missing genotypes in  HaplotypeArray . So the keyword  impute  is not relevant anymore.  # convert to Matrix{Float64}  h_f64   =   convert ( Matrix { Float64 },   h )   5x3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 1.0  1.0  0.0\n 0.0  2.0  2.0\n 0.0  1.0  0.0  By default  convert  translates genotypes according to the  additive  SNP model, which essentially counts the number of  minor allele  (0, 1 or 2) per genotype. Other SNP models are  dominant  and  recessive , both in terms of the  minor allele . When  A1  is the minor allele, genotypes are translated to real number according to     Genotype  HaplotypeArray  model=:additive  model=:dominant  model=:recessive      A1,A1  00  2  1  1    A1,A2  01  1  1  0    A2,A1  10  1  1  0    A2,A2  11  0  0  0     When  A2  is the minor allele, genotypes are translated according to     Genotype  HaplotypeArray  model=:additive  model=:dominant  model=:recessive      A1,A1  00  0  0  0    A1,A2  01  1  1  0    A2,A1  01  1  1  0    A2,A2  11  2  1  1     [ convert ( Vector { Float64 },   h [ 1 : 5 ,   3 ];   model   =   : additive )   convert ( Vector { Float64 },   h [ 1 : 5 ,   3 ];   model   =   : dominant )   convert ( Vector { Float64 },   h [ 1 : 5 ,   3 ];   model   =   : recessive )]   5x3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 2.0  1.0  1.0\n 0.0  0.0  0.0  By default  convert  does  not  center and scale genotypes. Setting the optional arguments  center=true, scale=true  centers genotypes at 2MAF and scales them by $[2 \\cdot \\text{MAF} \\cdot (1 - \\text{MAF})]^{-1/2}$. Mono-allelic SNPs (MAF=0) are not scaled.  [ convert ( Vector { Float64 },   h [:,   3 ])   convert ( Vector { Float64 },   h [:,   3 ];   center   =   true ,   scale   =   true )]   5x2 Array{Float64,2}:\n 0.0  -0.707107\n 0.0  -0.707107\n 0.0  -0.707107\n 2.0   2.82843 \n 0.0  -0.707107  copy!  is the in-place version of  convert() . Options such as GWAS loop over SNPs and perform statistical anlaysis for each SNP. This can be achieved by  g   =   zeros ( size ( h ,   1 ))  for   j   =   1 : size ( h ,   2 ) \n     copy! ( g ,   h [:,   j ];   model   =   : additive ) \n     # do statistical anlaysis  end", 
            "title": "Copy and convert"
        }
    ]
}