{
    "docs": [
        {
            "location": "/", 
            "text": "SnpArrays.jl\n\n\nCompressed storage for SNP data\n\n\nSnpArrays.jl\n implements the \nSnpArray\n, \nSnpData\n and \nHaplotypeArray\n types for handling biallelic genotypes.\n\n\n\n\nPackage Features\n\n\n\n\nRead and write \nPlink binary files\n.\n\n\nCalculate summary statistics (minor allele frequencies, minor allele, count of missing genotypes).\n\n\nSimple and intuitive manipulation (subsetting, adjoining, assignment, imputation) of array of genotypes.\n\n\nGenerate random genotypes according to minor allele frequencies.\n\n\nFilter an array of genotypes subject to minimum genotyping success rate per individual and per SNP.\n\n\nConvert genotypes into dense or sparse arrays of real numbers (minor allele counts).\n\n\nCalculate various empirical kinship matrices.\n\n\nExtract principal components.\n\n\n\n\n\n\nInstallation\n\n\nUse the Julia package manager to install SnpArrays.jl.\n\n\nPkg\n.\nclone\n(\nhttps://github.com/OpenMendel/SnpArrays.jl.git\n)\n\n\n\n\n\n\nThis package supports Julia \n0.5\n and \n0.6\n.\n\n\n\n\nManual Outline\n\n\n\n\nSnpArray\n\n\nConstructor\n\n\nSummary statistics\n\n\nFiltering\n\n\nRandom genotypes generation\n\n\nSubsetting\n\n\nAssignment\n\n\nConvert, copy and imputation\n\n\nEmpirical kinship matrix\n\n\nPrincipal components\n\n\n\n\n\n\nSnpData\n\n\nHaplotypeArray\n\n\nConstructor\n\n\nSummary statistics\n\n\nSubsetting and assignment\n\n\nCopy and convert", 
            "title": "Home"
        }, 
        {
            "location": "/#snparraysjl", 
            "text": "Compressed storage for SNP data  SnpArrays.jl  implements the  SnpArray ,  SnpData  and  HaplotypeArray  types for handling biallelic genotypes.", 
            "title": "SnpArrays.jl"
        }, 
        {
            "location": "/#package-features", 
            "text": "Read and write  Plink binary files .  Calculate summary statistics (minor allele frequencies, minor allele, count of missing genotypes).  Simple and intuitive manipulation (subsetting, adjoining, assignment, imputation) of array of genotypes.  Generate random genotypes according to minor allele frequencies.  Filter an array of genotypes subject to minimum genotyping success rate per individual and per SNP.  Convert genotypes into dense or sparse arrays of real numbers (minor allele counts).  Calculate various empirical kinship matrices.  Extract principal components.", 
            "title": "Package Features"
        }, 
        {
            "location": "/#installation", 
            "text": "Use the Julia package manager to install SnpArrays.jl.  Pkg . clone ( https://github.com/OpenMendel/SnpArrays.jl.git )   This package supports Julia  0.5  and  0.6 .", 
            "title": "Installation"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "SnpArray  Constructor  Summary statistics  Filtering  Random genotypes generation  Subsetting  Assignment  Convert, copy and imputation  Empirical kinship matrix  Principal components    SnpData  HaplotypeArray  Constructor  Summary statistics  Subsetting and assignment  Copy and convert", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/man/snparray/", 
            "text": "SnpArray\n\n\nSnpArray\n is an array of \nTuple{Bool,Bool}\n and adopts the same coding as the \nPlink binary format\n. If \nA1\n and \nA2\n are the two alleles, the coding rule is  \n\n\n\n\n\n\n\n\nGenotype\n\n\nSnpArray\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n(false,false)\n\n\n\n\n\n\nA1,A2\n\n\n(false,true)\n\n\n\n\n\n\nA2,A2\n\n\n(true,true)\n\n\n\n\n\n\nmissing\n\n\n(true,false)\n\n\n\n\n\n\n\n\nThe code \n(true,false)\n is reserved for missing genotype. Otherwise, the bit \ntrue\n represents one copy of allele \nA2\n. In a two-dimensional \nSnpArray\n, each row is a person and each column is a SNP.\n\n\nFor complete genotype data, for example, after imputation, consider using the \nHaplotypeArray\n type.\n\n\n\n\nConstructor\n\n\nThere are various ways to initialize a \nSnpArray\n.  \n\n\n\n\nSnpArray\n can be initialized from \nPlink binary files\n, say the sample data set hapmap3:\n\n\n\n\n;\nls\n \n-\nal\n \nhapmap3.*\n\n\n\n\n\n\n-rw-r--r--  1 huazhou  staff  1128171 Jun 19 14:43 hapmap3.bed\n-rw-r--r--  1 huazhou  staff   388672 Jun 19 14:43 hapmap3.bim\n-rw-r--r--  1 huazhou  staff     7136 Jun 19 14:43 hapmap3.fam\n-rw-r--r--  1 huazhou  staff   332960 Jun 19 14:43 hapmap3.map\n\n\n\n\n\nusing\n \nSnpArrays\n\n\nhapmap\n \n=\n \nSnpArray\n(\nhapmap3\n)\n\n\n\n\n\n\n324\u00d713928 SnpArrays.SnpArray{2}:\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (false, true)  (false, true)      (false, true)  (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n \u22ee                                            \u22f1                             \n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n\n\n\n\n\nBy default, the constructor figures out the number of individuals and SNPs from the \n.bim\n and \n.fam\n files.\n\n\n# rows are people; columns are SNPs\n\n\npeople\n,\n \nsnps\n \n=\n \nsize\n(\nhapmap\n)\n\n\n\n\n\n\n(324, 13928)\n\n\n\n\n\nAlternatively, users can supply keyword arguments \npeople\n and \nsnps\n to the constructor. In this case only the \n.bed\n file needs to be present.\n\n\nhapmap\n \n=\n \nSnpArray\n(\nhapmap3\n;\n \npeople\n \n=\n \n324\n,\n \nsnps\n \n=\n \n13928\n)\n\n\n\n\n\n\n324\u00d713928 SnpArrays.SnpArray{2}:\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (false, true)  (false, true)      (false, true)  (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n \u22ee                                            \u22f1                             \n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n\n\n\n\n\nInternally \nSnpArray\n stores data as \nBitArray\ns and consumes approximately the same amount of memory as the Plink \nbed\n file size.\n\n\n# memory usage, bed file size\n\n\nBase\n.\nsummarysize\n(\nhapmap\n),\n \nfilesize\n(\nhapmap3.bed\n)\n\n\n\n\n\n\n(1128256, 1128171)\n\n\n\n\n\n\n\nSnpArray\n can be initialized from a matrix of A1 allele counts.\n\n\n\n\nSnpArray\n(\nrand\n(\n0\n:\n2\n,\n \n5\n,\n \n3\n))\n\n\n\n\n\n\n5\u00d73 SnpArrays.SnpArray{2}:\n (false, false)  (false, false)  (false, true) \n (true, true)    (true, true)    (false, true) \n (false, true)   (false, false)  (false, false)\n (false, false)  (false, true)   (false, true) \n (true, true)    (false, false)  (false, true)\n\n\n\n\n\n\n\nSnpArray(m, n)\n generates an m by n \nSnpArray\n of all A1 alleles.\n\n\n\n\ns\n \n=\n \nSnpArray\n(\n5\n,\n \n3\n)\n\n\n\n\n\n\n5\u00d73 SnpArrays.SnpArray{2}:\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n\n\n\n\n\n\n\nSummary statistics\n\n\nsummarize\n function computes the following summary statistics of a \nSnpArray\n:  \n\n\n\n\nmaf\n: minor allele frequencies, taking into account of missingness.\n\n\nminor_allele\n: a \nBitVector\n indicating the minor allele for each SNP.   \nminor_allele[j]==true\n means A1 is the minor allele for SNP j; \nminor_allele[j]==false\n means A2 is the minor allele for SNP j.\n\n\nmissings_by_snp\n: number of missing genotypes for each snp.\n\n\nmissings_by_person\n: number of missing genotypes for each person.\n\n\n\n\nmaf\n,\n \nminor_allele\n,\n \nmissings_by_snp\n,\n \nmissings_by_person\n \n=\n \nsummarize\n(\nhapmap\n)\n\n\n# minor allele frequencies\n\n\nmaf\n\n\n\n\n\n\n1\u00d713928 RowVector{Float64,Array{Float64,1}}:\n 0.0  0.0776398  0.324074  0.191589  \u2026  0.00154321  0.0417957  0.00617284\n\n\n\n\n\n# total number of missing genotypes\n\n\nsum\n(\nmissings_by_snp\n),\n \nsum\n(\nmissings_by_person\n)\n\n\n\n\n\n\n(11894, 11894)\n\n\n\n\n\n# proportion of missing genotypes\n\n\nsum\n(\nmissings_by_snp\n)\n \n/\n \nlength\n(\nhapmap\n)\n\n\n\n\n\n\n0.0026356890108565393\n\n\n\n\n\n\n\nFiltering\n\n\nIn almost all analyses, SNPs and individuals with low genotyping success rates are ignored. This filtering step is an important tool for removing likely false positives from association testing, as genotyping failure often occurs preferentially in cases or controls, or is correlated with the quantitative trait. \nfilter(s, min_success_rate_per_snp, min_success_rate_per_person)\n does filtering according to the specified success rates for SNPs and people. Default is 0.98 for both.\n\n\n# filtering SNPs and people to have both success rates above 0.98\n\n\nsnp_idx\n,\n \nperson_idx\n \n=\n \nfilter\n(\nhapmap\n,\n \n0.98\n,\n \n0.98\n)\n\n\n# summary statistics of the filtered SnpArray\n\n\n_\n,\n \n_\n,\n \nmissings_by_snp_filtered\n,\n \nmissings_by_person_filtered\n \n=\n \nsummarize\n(\nhapmap\n[\nperson_idx\n,\n \nsnp_idx\n]);\n\n\n\n\n\n\n# minimum SNP genotyping success rate after filtering \u2265 0.98\n\n\n1.0\n \n-\n \nmaximum\n(\nmissings_by_snp_filtered\n)\n \n/\n \nlength\n(\nmissings_by_person_filtered\n)\n\n\n\n\n\n\n0.9813084112149533\n\n\n\n\n\n# minimum person genotyping success rate after filtering \u2265 0.98\n\n\n1.0\n \n-\n \nmaximum\n(\nmissings_by_person_filtered\n)\n \n/\n \nlength\n(\nmissings_by_snp_filtered\n)\n\n\n\n\n\n\n0.9818511796733213\n\n\n\n\n\n\n\nRandom genotypes generation\n\n\nrandgeno(a1freq)\n generates a random genotype according to A1 allele frequency \na1freq\n.\n\n\nrandgeno\n(\n0.5\n)\n\n\n\n\n\n\n(false, true)\n\n\n\n\n\nrandgeno(maf, minor_allele)\n generates a random genotype according to minor allele frequency \nmaf\n and whether the minor allele is A1 (\nminor_allele==true\n) or A2 (\nminor_allele==false\n).\n\n\nrandgeno\n(\n0.25\n,\n \ntrue\n)\n\n\n\n\n\n\n(true, true)\n\n\n\n\n\nrandgeno(n, maf, minor_allele)\n generates a vector of random genotypes according to a common minor allele frequency \nmaf\n and the minor allele.\n\n\nrandgeno\n(\n10\n,\n \n0.25\n,\n \ntrue\n)\n\n\n\n\n\n\n10-element SnpArrays.SnpArray{1}:\n (false, true)\n (true, true) \n (true, true) \n (false, true)\n (false, true)\n (false, true)\n (false, true)\n (true, true) \n (false, true)\n (true, true)\n\n\n\n\n\nrandgeno(m, n, maf, minor_allele)\n generates a random $m$-by-$n$ \nSnpArray\n according to a vector of minor allele frequencies \nmaf\n and a minor allele indicator vector. The lengths of both vectors should be \nn\n.\n\n\n# this is a random replicate of the hapmap data\n\n\nrandgeno\n(\nsize\n(\nhapmap\n),\n \nmaf\n,\n \nminor_allele\n)\n\n\n\n\n\n\n324\u00d713928 SnpArrays.SnpArray{2}:\n (true, true)  (true, true)   (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)       (false, true)  (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)       (true, true)   (true, true)\n \u22ee                                            \u22f1                             \n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (false, true)  (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n\n\n\n\n\n\n\nSubsetting\n\n\nSubsetting a \nSnpArray\n works the same way as subsetting any other arrays.\n\n\n# genotypes of the 1st person\n\n\nhapmap\n[\n1\n,\n \n:\n]\n\n\n\n\n\n\n13928-element SnpArrays.SnpArray{1}:\n (true, true)  \n (true, true)  \n (false, false)\n (true, true)  \n (true, true)  \n (true, true)  \n (false, true) \n (false, true) \n (true, true)  \n (false, true) \n (true, true)  \n (true, true)  \n (false, false)\n \u22ee             \n (false, true) \n (false, true) \n (true, true)  \n (false, true) \n (false, true) \n (false, true) \n (false, true) \n (false, true) \n (false, true) \n (true, true)  \n (true, true)  \n (true, true)\n\n\n\n\n\n# genotypes of the 5th SNP\n\n\nhapmap\n[\n:\n,\n \n5\n]\n\n\n\n\n\n\n324-element SnpArrays.SnpArray{1}:\n (true, true)  \n (true, true)  \n (false, true) \n (false, true) \n (true, true)  \n (false, false)\n (false, false)\n (true, true)  \n (true, true)  \n (true, true)  \n (true, true)  \n (true, true)  \n (false, true) \n \u22ee             \n (false, false)\n (true, true)  \n (false, true) \n (true, true)  \n (true, true)  \n (true, true)  \n (true, true)  \n (true, true)  \n (false, true) \n (true, true)  \n (true, true)  \n (true, true)\n\n\n\n\n\n# subsetting both persons and SNPs\n\n\nhapmap\n[\n1\n:\n5\n,\n \n5\n:\n10\n]\n\n\n\n\n\n\n5\u00d76 SnpArrays.SnpArray{2}:\n (true, true)   (true, true)  (false, true)  \u2026  (true, true)   (false, true)\n (true, true)   (true, true)  (true, true)      (true, true)   (false, true)\n (false, true)  (true, true)  (true, true)      (false, true)  (true, true) \n (false, true)  (true, true)  (true, true)      (true, true)   (false, true)\n (true, true)   (true, true)  (true, true)      (true, true)   (false, true)\n\n\n\n\n\n# filter out rare SNPs with MAF \n 0.05\n\n\nhapmap\n[\n:\n,\n \nmaf\n \n.\u2265\n \n0.05\n]\n\n\n\n\n\n\n324\u00d712085 SnpArrays.SnpArray{2}:\n (true, true)   (false, false)  \u2026  (false, true)  (false, true)\n (false, true)  (false, true)      (true, true)   (true, true) \n (true, true)   (false, true)      (true, true)   (true, true) \n (true, true)   (false, true)      (false, true)  (false, true)\n (true, true)   (false, true)      (true, true)   (true, true) \n (false, true)  (true, true)    \u2026  (false, true)  (false, true)\n (true, true)   (true, true)       (true, true)   (true, true) \n (true, true)   (false, false)     (true, true)   (true, true) \n (true, true)   (false, true)      (true, true)   (true, true) \n (true, true)   (false, true)      (false, true)  (false, true)\n (true, true)   (false, true)   \u2026  (true, true)   (true, true) \n (true, true)   (true, true)       (false, true)  (false, true)\n (true, true)   (false, false)     (false, true)  (false, true)\n \u22ee                              \u22f1                              \n (true, true)   (false, true)      (false, true)  (false, true)\n (true, true)   (false, false)     (false, true)  (false, true)\n (true, true)   (false, false)     (true, true)   (true, true) \n (true, true)   (false, false)  \u2026  (true, true)   (true, true) \n (true, true)   (false, true)      (true, true)   (true, true) \n (true, true)   (true, true)       (false, true)  (false, true)\n (true, true)   (false, true)      (false, true)  (false, true)\n (true, true)   (false, true)      (true, true)   (true, true) \n (true, true)   (false, false)  \u2026  (false, true)  (false, true)\n (true, true)   (false, true)      (false, true)  (false, true)\n (true, true)   (false, false)     (false, true)  (false, true)\n (true, true)   (false, false)     (true, true)   (true, true)\n\n\n\n\n\n# filter out individuals with genotyping success rate \n 0.90\n\n\nhapmap\n[\nmissings_by_person\n \n/\n \npeople\n \n.\n \n0.1\n,\n \n:\n]\n\n\n\n\n\n\n220\u00d713928 SnpArrays.SnpArray{2}:\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (false, true)  (false, true)      (false, true)  (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n \u22ee                                            \u22f1                             \n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n\n\n\n\n\nview\n creates views of subarray without copying data and improve efficiency in many calculations.\n\n\nmafcommon\n,\n \n=\n \nsummarize\n(\nview\n(\nhapmap\n,\n \n:\n,\n \nmaf\n \n.\u2265\n \n0.05\n))\n\n\nmafcommon\n\n\n\n\n\n\n1\u00d712085 RowVector{Float64,Array{Float64,1}}:\n 0.0776398  0.324074  0.191589  \u2026  0.310937  0.23913  0.23913  0.23913\n\n\n\n\n\n\n\nAssignment\n\n\nIt is possible to assign specific genotypes to a \nSnpArray\n entry.\n\n\nhapmap\n[\n1\n,\n \n1\n]\n\n\n\n\n\n\n(true, true)\n\n\n\n\n\nhapmap\n[\n1\n,\n \n1\n]\n \n=\n \n(\nfalse\n,\n \ntrue\n)\n\n\nhapmap\n[\n1\n,\n \n1\n]\n\n\n\n\n\n\n(false, true)\n\n\n\n\n\nhapmap\n[\n1\n,\n \n1\n]\n \n=\n \nNaN\n\n\nhapmap\n[\n1\n,\n \n1\n]\n\n\n\n\n\n\n(true, false)\n\n\n\n\n\nhapmap\n[\n1\n,\n \n1\n]\n \n=\n \n2\n\n\nhapmap\n[\n1\n,\n \n1\n]\n\n\n\n\n\n\n(true, true)\n\n\n\n\n\nSubsetted assignment such as \nhapmap[:, 1] = Nan\n is also valid.\n\n\n\n\nConvert, copy and imputation\n\n\nIn most analyses we convert a whole \nSnpArray\n or slices of it to numeric arrays (matrix of \nminor allele counts\n) for statistical analysis. Keep in mind that the storage of resultant data can be up to 32 fold larger than that of the original \nSnpArray\n. Fortunately, rich collection of data types in \nJulia\n allow us choose one that fits into memory. Below are estimates of memory usage for some common data types with \nn\n persons and \np\n SNPs. Here MAF denotes the \naverage\n minor allele frequencies.\n\n\n\n\nSnpArray\n: $0.25np$ bytes\n\n\nMatrix{Int8}\n: $np$ bytes\n\n\nMatrix{Float16}\n: $2np$ bytes\n\n\nMatrix{Float32}\n: $4np$ bytes\n\n\nMatrix{Float64}\n: $8np$ bytes\n\n\nSparseMatrixCSC{Float64,Int64}\n: $16 \\cdot \\text{NNZ} + 8(p+1) \\approx 16np(2\\text{MAF}(1-\\text{MAF})+\\text{MAF}^2) + 8(p+1) = 16np \\cdot \\text{MAF}(2-\\text{MAF}) + 8(p+1)$ bytes. When the average MAF=0.25, this is about $7np$ bytes. When MAF=0.025, this is about $0.8np$ bypes, 10 fold smaller than the \nMatrix{Float64}\n type.\n\n\nSparseMatrixCSC{Int8,UInt32}\n: $5 \\cdot \\text{NNZ} + 4(p+1) \\approx 5np(2\\text{MAF}(1-\\text{MAF})+\\text{MAF}^2) + 4(p+1) = 5np \\cdot \\text{MAF}(2-\\text{MAF}) + 4(p+1)$ bytes. When the average MAF=0.25, this is about $2.2np$ bytes. When MAF=0.08, this is about $0.8np$ bypes, 10 fold smaller than \nMatrix{Float64}\n type.\n\n\nTwo \nSparseMatrixCSC{Bool,Int64}\n: $2np \\cdot \\text{MAF} \\cdot 9 + 16(p+1) = 18 np \\cdot \\text{MAF} + 16(p+1)$ bytes. When the average MAF=0.25, this is about $4.5np$ bytes. When MAF=0.045, this is about $0.8np$ bytes, 10 fold smaller than \nMatrix{Float64}\n type.\n\n\n\n\nTo be concrete, consider 2 typical data sets:  \n\n\n\n\nCOPD (GWAS): $n = 6670$ individuals, $p = 630998$ SNPs, average MAF is 0.2454.\n\n\nGAW19 (sequencing study): $n = 959$ individuals, $p = 8348674$ SNPs, average MAF is 0.085.\n\n\n\n\n\n\n\n\n\n\nData Type\n\n\nCOPD\n\n\nGAW19\n\n\n\n\n\n\n\n\n\n\nSnpArray\n\n\n1.05GB\n\n\n2GB\n\n\n\n\n\n\nMatrix{Float64}\n\n\n33.67GB\n\n\n64.05GB\n\n\n\n\n\n\nSparseMatrixCSC{Float64,Int64}\n\n\n29GB\n\n\n20.82GB\n\n\n\n\n\n\nSparseMatrixCSC{Bool,Int64}\n\n\n18.6GB\n\n\n12.386GB\n\n\n\n\n\n\n\n\nApparently for data sets with a majority of rare variants, converting to sparse matrices saves memory and often brings computational advantages too. In the \nSparseMatrixCSC\n format, the integer type of the row indices \nrowval\n and column pointer \ncolptr\n should have maximal allowable value larger than the number of nonzeros in the matrix. The \nInexactError()\n error encountered during conversion often indicates that the integer type has a too small range. The utility function \nestimatesize\n conveniently estimates memory usage in bytes for the input data type.\n\n\n# estimated memory usage if convert to Matrix{Float64}\n\n\nestimatesize\n(\npeople\n,\n \nsnps\n,\n \nMatrix\n{\nFloat64\n})\n\n\n\n\n\n\n3.6101376e7\n\n\n\n\n\n# convert to Matrix{Float64}\n\n\nhapmapf64\n \n=\n \nconvert\n(\nMatrix\n{\nFloat64\n},\n \nhapmap\n)\n\n\n\n\n\n\n324\u00d713928 Array{Float64,2}:\n 0.0  0.0  2.0  0.0  0.0  0.0  1.0  1.0  \u2026  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  1.0  1.0  1.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  1.0  1.0  1.0  0.0  0.0  2.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  1.0  0.0  0.0  1.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  2.0  0.0  0.0  0.0  \u2026  2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  2.0  0.0  0.0  2.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0  \u2026  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n \u22ee                        \u22ee              \u22f1                      \u22ee            \n 0.0  0.0  1.0  0.0  2.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  2.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  1.0  0.0  0.0  0.0  1.0  \u2026  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  1.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0  \u2026  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  1.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n# actual memory usage of Matrix{Float64}\n\n\nBase\n.\nsummarysize\n(\nhapmapf64\n)\n\n\n\n\n\n\n36101376\n\n\n\n\n\n# average maf of the hapmap3 data set\n\n\nmean\n(\nmaf\n)\n\n\n\n\n\n\n0.222585591341583\n\n\n\n\n\n# estimated memory usage if convert to SparseMatrixCSC{Float32, UInt32} matrix\n\n\nestimatesize\n(\npeople\n,\n \nsnps\n,\n \nSparseMatrixCSC\n{\nFloat32\n,\n \nUInt32\n},\n \nmean\n(\nmaf\n))\n\n\n\n\n\n\n1.4338389205819245e7\n\n\n\n\n\n# convert to SparseMatrixCSC{Float32, UInt32} matrix\n\n\nhapmapf32sp\n \n=\n \nconvert\n(\nSparseMatrixCSC\n{\nFloat32\n,\n \nUInt32\n},\n \nhapmap\n)\n\n\n\n\n\n\n324\u00d713928 SparseMatrixCSC{Float32,UInt32} with 1614876 stored entries:\n  [2    ,     2]  =  1.0\n  [6    ,     2]  =  1.0\n  [15   ,     2]  =  1.0\n  [31   ,     2]  =  1.0\n  [33   ,     2]  =  1.0\n  [35   ,     2]  =  1.0\n  [43   ,     2]  =  1.0\n  [44   ,     2]  =  1.0\n  [50   ,     2]  =  1.0\n  [54   ,     2]  =  1.0\n  \u22ee\n  [135  , 13927]  =  1.0\n  [148  , 13927]  =  1.0\n  [160  , 13927]  =  1.0\n  [164  , 13927]  =  2.0\n  [167  , 13927]  =  1.0\n  [185  , 13927]  =  1.0\n  [266  , 13927]  =  1.0\n  [280  , 13927]  =  1.0\n  [288  , 13927]  =  1.0\n  [118  , 13928]  =  2.0\n  [231  , 13928]  =  2.0\n\n\n\n\n\n# actual memory usage if convert to SparseMatrixCSC{Float32, UInt32} matrix\n\n\nBase\n.\nsummarysize\n(\nhapmapf32sp\n)\n\n\n\n\n\n\n12974764\n\n\n\n\n\nBy default the \nconvert()\n method converts missing genotypes to \nNaN\n.\n\n\n# number of missing genotypes\n\n\ncountnz\n(\nisnan\n.\n(\nhapmap\n)),\n \ncountnz\n(\nisnan\n.\n(\nhapmapf64\n))\n\n\n\n\n\n\n(11894, 11894)\n\n\n\n\n\nOne can enforce \ncrude imputation\n by setting the optional argument \nimpute=true\n. Imputation is done by generating two random alleles according to the minor allele frequency. This is a neutral but not an optimal strategy, and users should impute missing genotypes by more advanced methods.\n\n\nhapmapf64impute\n \n=\n \nconvert\n(\nMatrix\n{\nFloat64\n},\n \nhapmap\n;\n \nimpute\n \n=\n \ntrue\n)\n\n\ncountnz\n(\nisnan\n.\n(\nhapmapf64impute\n))\n\n\n\n\n\n\n0\n\n\n\n\n\nBy default \nconvert()\n translates genotypes according to the \nadditive\n SNP model, which essentially counts the number of \nminor allele\n (0, 1 or 2) per genotype. Other SNP models are \ndominant\n and \nrecessive\n, both in terms of the \nminor allele\n. When \nA1\n is the minor allele, genotypes are translated to real number according to\n\n\n\n\n\n\n\n\nGenotype\n\n\nSnpArray\n\n\nmodel=:additive\n\n\nmodel=:dominant\n\n\nmodel=:recessive\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n(false,false)\n\n\n2\n\n\n1\n\n\n1\n\n\n\n\n\n\nA1,A2\n\n\n(false,true)\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A2\n\n\n(true,true)\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\nmissing\n\n\n(true,false)\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\n\n\n\n\n\n\nWhen \nA2\n is the minor allele, genotypes are translated according to\n\n\n\n\n\n\n\n\nGenotype\n\n\nSnpArray\n\n\nmodel=:additive\n\n\nmodel=:dominant\n\n\nmodel=:recessive\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n(false,false)\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\nA1,A2\n\n\n(false,true)\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A2\n\n\n(true,true)\n\n\n2\n\n\n1\n\n\n1\n\n\n\n\n\n\nmissing\n\n\n(true,false)\n\n\nNaN\n\n\nNaN\n\n\nNaN\n\n\n\n\n\n\n\n\n[\nconvert\n(\nVector\n{\nFloat64\n},\n \nhapmap\n[\n1\n:\n10\n,\n \n5\n];\n \nmodel\n \n=\n \n:\nadditive\n)\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nhapmap\n[\n1\n:\n10\n,\n \n5\n];\n \nmodel\n \n=\n \n:\ndominant\n)\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nhapmap\n[\n1\n:\n10\n,\n \n5\n];\n \nmodel\n \n=\n \n:\nrecessive\n)]\n\n\n\n\n\n\n10\u00d73 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 1.0  1.0  0.0\n 1.0  1.0  0.0\n 0.0  0.0  0.0\n 2.0  1.0  1.0\n 2.0  1.0  1.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\nBy default \nconvert()\n does \nnot\n center and scale genotypes. Setting the optional arguments \ncenter=true, scale=true\n centers genotypes at 2MAF and scales them by $[2 \\cdot \\text{MAF} \\cdot (1 - \\text{MAF})]^{-1/2}$. Mono-allelic SNPs (MAF=0) are not scaled.\n\n\n[\nconvert\n(\nVector\n{\nFloat64\n},\n \nhapmap\n[\n:\n,\n \n5\n])\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nhapmap\n[\n:\n,\n \n5\n];\n \ncenter\n \n=\n \ntrue\n,\n \nscale\n \n=\n \ntrue\n)]\n\n\n\n\n\n\n324\u00d72 Array{Float64,2}:\n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n 1.0   0.167017\n 0.0  -1.25702 \n 2.0   1.59106 \n 2.0   1.59106 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n \u22ee             \n 2.0   1.59106 \n 0.0  -1.25702 \n 1.0   0.167017\n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702\n\n\n\n\n\ncopy!()\n is the in-place version of \nconvert()\n. Options such as GWAS loop over SNPs and perform statistical anlaysis for each SNP. This can be achieved by\n\n\ng\n \n=\n \nzeros\n(\npeople\n)\n\n\nfor\n \nj\n \n=\n \n1\n:\nsnps\n\n    \ncopy!\n(\ng\n,\n \nhapmap\n[\n:\n,\n \nj\n];\n \nmodel\n \n=\n \n:\nadditive\n,\n \nimpute\n \n=\n \ntrue\n)\n\n    \n# do statistical anlaysis\n\n\nend\n\n\n\n\n\n\n\n\nEmpirical kinship matrix\n\n\ngrm\n function computes the empirical kinship matrix using either the genetic relationship matrix, \ngrm(A, model=:GRM)\n, or the method of moment method, \ngrm(A, model=:MoM)\n. \n\n\n\n\nNote\n\n\nMissing genotypes are imputed according to minor allele frequencies on the fly.\n\n\n\n\n\n\nNote\n\n\nIt is often necessary to filter SNPs according to minor allele frequency and LD before calculating empirical kinship matrix.\n\n\n\n\nBy default, \ngrm\n exlcude SNPs with minor allele frequency below 0.01. This can be changed by the keyword argument \nmaf_threshold\n.\n\n\n# GRM using all SNPs with MAF \u2265 0.01. Same as\n\n\n# grm(hapmap; maf_threshold = 0.01)\n\n\ngrm\n(\nhapmap\n)\n\n\n\n\n\n\n324\u00d7324 Array{Float64,2}:\n 0.571462   0.0465067  0.0198863  \u2026  0.065456   0.0716354  0.0653478\n 0.0465067  0.544896   0.028444      0.0515233  0.0456809  0.0633915\n 0.0198863  0.028444   0.520507      0.046051   0.0302884  0.0366246\n 0.0484459  0.0369766  0.0293501     0.060103   0.0660171  0.0601609\n 0.052807   0.0424252  0.0264585     0.0718885  0.0583893  0.0658839\n 0.0453662  0.0316632  0.0382386  \u2026  0.070662   0.0566399  0.0650759\n 0.0401015  0.022318   0.0119087     0.044437   0.0381739  0.0372612\n 0.0410669  0.0386841  0.0210986     0.0574887  0.0547491  0.0663823\n 0.0300075  0.0309477  0.0172097     0.0340103  0.0460311  0.0382384\n 0.0394993  0.0422916  0.0261469     0.0668     0.0576783  0.0493439\n 0.0480282  0.045924   0.0233717  \u2026  0.0586062  0.0628982  0.0611232\n 0.0605082  0.0394706  0.0379736     0.0660183  0.058135   0.0701802\n 0.0360314  0.0439399  0.02689       0.0572845  0.0701882  0.0637648\n \u22ee                                \u22f1                                 \n 0.0581814  0.0556006  0.0380623     0.0865167  0.0865612  0.0971798\n 0.0675241  0.0521455  0.0340608     0.0917849  0.0804942  0.0858172\n 0.0679571  0.0557595  0.0388875     0.0898047  0.0842924  0.0853568\n 0.0654182  0.0570707  0.0401996  \u2026  0.0874426  0.0763659  0.0889914\n 0.0626962  0.0556636  0.0368206     0.0788686  0.0730769  0.0814711\n 0.0648935  0.0612453  0.0397923     0.0890301  0.0900733  0.0818672\n 0.0623441  0.0600386  0.0386961     0.0821445  0.0851567  0.0805624\n 0.0620668  0.0630181  0.0336136     0.0933894  0.0899758  0.0865969\n 0.0657627  0.0631312  0.0334048  \u2026  0.0974675  0.0793873  0.0865828\n 0.065456   0.0515233  0.046051      0.603312   0.0821679  0.0903656\n 0.0716354  0.0456809  0.0302884     0.0821679  0.595324   0.0828236\n 0.0653478  0.0633915  0.0366246     0.0903656  0.0828236  0.582924\n\n\n\n\n\n# GRM using all SNPs with MAF \u2265 0.05\n\n\ngrm\n(\nhapmap\n;\n \nmaf_threshold\n \n=\n \n0.05\n)\n\n\n\n\n\n\n324\u00d7324 Array{Float64,2}:\n 0.569832   0.0534955  0.0229106  \u2026  0.0736094  0.0777382  0.0728604\n 0.0534955  0.542797   0.0292553     0.0565556  0.050179   0.0687166\n 0.0229106  0.0292553  0.521398      0.0516482  0.03499    0.0406527\n 0.0531014  0.0397342  0.0315786     0.061866   0.0725732  0.0652814\n 0.0555008  0.0457758  0.0260288     0.0763692  0.063647   0.0720957\n 0.048623   0.0330879  0.041643   \u2026  0.0754922  0.0612846  0.0653836\n 0.0425229  0.0256048  0.0152978     0.0465058  0.038005   0.0432299\n 0.0445646  0.0417373  0.0241854     0.0573711  0.0568992  0.0665918\n 0.0315382  0.0336913  0.0200753     0.036809   0.0504817  0.0416076\n 0.041739   0.0440421  0.0298305     0.0711053  0.063812   0.0530766\n 0.0551959  0.0476215  0.0240236  \u2026  0.0627489  0.0680972  0.0673988\n 0.0662055  0.0427204  0.0409013     0.0744466  0.0654627  0.0733776\n 0.0363799  0.0475432  0.0301813     0.0635413  0.0731001  0.0677743\n \u22ee                                \u22f1                                 \n 0.0606893  0.0571803  0.0422398     0.0920599  0.0920055  0.105568 \n 0.072268   0.0547569  0.037554      0.0978259  0.0857098  0.0927913\n 0.0673625  0.0593351  0.0407456     0.0922872  0.0910686  0.0912259\n 0.0708107  0.0637208  0.0453826  \u2026  0.0935781  0.0829951  0.0937371\n 0.0693228  0.0591013  0.0387746     0.0862804  0.0816425  0.089975 \n 0.0694049  0.0632493  0.0442108     0.0936805  0.0956861  0.0892517\n 0.0662482  0.0621341  0.0401302     0.0862024  0.088719   0.087849 \n 0.0683031  0.0678069  0.0392417     0.0996427  0.0917543  0.0865936\n 0.07229    0.0673767  0.0390863  \u2026  0.106276   0.0842234  0.0901547\n 0.0736094  0.0565556  0.0516482     0.590262   0.0900209  0.094751 \n 0.0777382  0.050179   0.03499       0.0900209  0.587857   0.08857  \n 0.0728604  0.0687166  0.0406527     0.094751   0.08857    0.570328\n\n\n\n\n\n# GRM using every other SNP, with maf \u2265 0.01\n\n\ngrm\n(\nview\n(\nhapmap\n,\n \n:\n,\n \n1\n:\n2\n:\nsnps\n))\n\n\n\n\n\n\n324\u00d7324 Array{Float64,2}:\n 0.558921   0.0430417  0.02776    \u2026  0.0675216  0.0737988  0.0675734\n 0.0430417  0.557352   0.0283227     0.0581735  0.0459756  0.0563325\n 0.02776    0.0283227  0.513037      0.0403644  0.0401923  0.0482823\n 0.0453687  0.0459315  0.0274437     0.0522127  0.062348   0.0567562\n 0.0525321  0.0482946  0.0261682     0.0675415  0.0565141  0.0658733\n 0.0527773  0.0407108  0.0395822  \u2026  0.0763428  0.0629453  0.0538004\n 0.0400413  0.0270224  0.0174656     0.0471662  0.0344731  0.0342288\n 0.0477958  0.0380087  0.026397      0.0591346  0.0559213  0.0690588\n 0.027236   0.0232717  0.0199212     0.0335014  0.0438624  0.0362997\n 0.0316181  0.0401905  0.0238639     0.0599384  0.04131    0.0507507\n 0.0489757  0.0506289  0.0211802  \u2026  0.0629766  0.0652554  0.0533221\n 0.0625952  0.0495802  0.040138      0.0663878  0.0647589  0.0606609\n 0.0255679  0.0432178  0.0227905     0.0548997  0.0688556  0.0638942\n \u22ee                                \u22f1                                 \n 0.0603235  0.0507125  0.0414195     0.0874199  0.0850151  0.102226 \n 0.0670063  0.0605808  0.0322251     0.0900799  0.0761188  0.0819028\n 0.0689632  0.0537943  0.0396167     0.0845196  0.0816942  0.0965653\n 0.0655601  0.0590466  0.0417276  \u2026  0.0933334  0.0772525  0.0827035\n 0.0632019  0.0619054  0.0411649     0.0734338  0.0695185  0.0872505\n 0.0667202  0.0637907  0.0420585     0.0769856  0.0831787  0.0846128\n 0.0630419  0.0648211  0.0313507     0.0866063  0.0920158  0.0833748\n 0.059878   0.0622266  0.0347955     0.0952744  0.0918524  0.0842268\n 0.0763973  0.0662859  0.0401014  \u2026  0.102024   0.0748581  0.0900122\n 0.0675216  0.0581735  0.0403644     0.573673   0.0699285  0.0957602\n 0.0737988  0.0459756  0.0401923     0.0699285  0.576885   0.0749023\n 0.0675734  0.0563325  0.0482823     0.0957602  0.0749023  0.588357\n\n\n\n\n\n# MoM using all SNPs with MAF \u2265 0.01\n\n\ngrm\n(\nhapmap\n;\n \nmethod\n \n=\n \n:\nMoM\n)\n\n\n\n\n\n\n324\u00d7324 Array{Float64,2}:\n 0.539557    0.0352687  0.00335917  \u2026  0.0544144  0.0642236  0.0514598\n 0.0352687   0.51793    0.0137593      0.0424779  0.0395233  0.0507507\n 0.00335917  0.0137593  0.499611       0.0319596  0.0207321  0.0199049\n 0.0440143   0.0292413  0.0234504      0.0527598  0.0698964  0.0501598\n 0.0455507   0.0333778  0.0156502      0.0656418  0.0571326  0.0567781\n 0.0324323   0.0209685  0.0259322   \u2026  0.0593781  0.0495689  0.0488598\n 0.0252231   0.0111593  0.00288644     0.0314868  0.0314868  0.0247504\n 0.0256958   0.0285322  0.00915016     0.0388142  0.0466143  0.047087 \n 0.0209685   0.0253413  0.012932       0.0297141  0.0486234  0.0306595\n 0.0210867   0.0255777  0.010332       0.0529962  0.0507507  0.0325505\n 0.0364505   0.0337323  0.00548647  \u2026  0.0498053  0.0561872  0.0501598\n 0.0488598   0.0323141  0.0275868      0.0559508  0.0553599  0.0524053\n 0.0314868   0.0415324  0.0242776      0.0587872  0.0710783  0.0580781\n \u22ee                                  \u22f1                                 \n 0.0421233   0.0411779  0.0253413      0.0708419  0.0797057  0.0819511\n 0.0624509   0.0482689  0.0269959      0.0919967  0.0795875  0.0837239\n 0.0551235   0.0449597  0.0261686      0.0804148  0.0817148  0.0726147\n 0.0459052   0.0423597  0.0242776   \u2026  0.0727328  0.0630418  0.0706055\n 0.0561872   0.0532326  0.0295959      0.0782875  0.0711965  0.074742 \n 0.0533508   0.0544144  0.0308959      0.0789966  0.0864421  0.0722601\n 0.0526417   0.0509871  0.0295959      0.0778147  0.0845512  0.0745056\n 0.0492143   0.052878   0.0209685      0.0823057  0.0845512  0.0724965\n 0.0506325   0.0481507  0.0221503   \u2026  0.0883331  0.0740329  0.0696601\n 0.0544144   0.0424779  0.0319596      0.561421   0.0811239  0.0766329\n 0.0642236   0.0395233  0.0207321      0.0811239  0.56733    0.0695419\n 0.0514598   0.0507507  0.0199049      0.0766329  0.0695419  0.533766\n\n\n\n\n\n\n\nPrincipal components\n\n\nPrincipal compoenent analysis is widely used in genome-wide association analysis (GWAS) for adjusting population substructure. \npca(A, pcs)\n computes the top \npcs\n principal components of a \nSnpArray\n. Each SNP is centered at $2\\text{MAF}$ and scaled by $[2\\text{MAF}(1-\\text{MAF})]^{-1/2}$. The output is  \n\n\n\n\npcscore\n: top \npcs\n eigen-SNPs, or principal scores, in each column\n\n\npcloading\n: top \npcs\n eigen-vectors, or principal loadings, in each column\n\n\npcvariance\n: top \npcs\n eigen-values, or principal variances\n\n\n\n\nMissing genotypes are imputed according the minor allele frequencies on the fly. This implies that, in the presence of missing genotypes, running the function on the same \nSnpArray\n twice may produce slightly different answers. For reproducibility, it is a good practice to set the random seed before each function that does imputation on the fly.\n\n\nsrand\n(\n123\n)\n \n# set seed\n\n\npcscore\n,\n \npcloading\n,\n \npcvariance\n \n=\n \npca\n(\nhapmap\n,\n \n3\n)\n\n\n\n\n\n\n([-38.7231 -1.2983 -7.00541; -32.6096 -1.21052 -3.3232; \u2026 ; -48.9263 -2.06102 2.17374; -48.8627 0.274894 6.49518], [7.47821e-19 1.01333e-18 1.65076e-19; 0.00143962 -0.0042375 -0.00311816; \u2026 ; 0.00313326 -0.00427486 -0.0152038; -9.09523e-5 -0.00287777 0.0037855], [1841.4, 225.324, 70.7084])\n\n\n\n\n\nTo use eigen-SNPs for plotting or as covariates in GWAS, we typically scale them by their standard deviations so that they have mean zero and unit variance.\n\n\n# standardize eigen-SNPs before plotting or GWAS\n\n\nscale!\n(\npcscore\n,\n \n1\n \n./\n \nsqrt\n.\n(\npcvariance\n))\n\n\nstd\n(\npcscore\n,\n \n1\n)\n\n\n\n\n\n\n1\u00d73 Array{Float64,2}:\n 1.0  1.0  1.0\n\n\n\n\n\nInternally \npca\n converts \nSnpArray\n to the matrix of minor allele counts. The default format is \nMatrix{Float64}\n, which can easily exceed memory limit. Users have several options when the default \nMatrix{Float64}\n cannot fit into memory.  \n\n\n\n\nUse other intermediate matrix types.\n\n\n\n\n# use single precision matrix and display the principal variances\n\n\n# approximately same answer as double precision\n\n\nsrand\n(\n123\n)\n\n\npca\n(\nhapmap\n,\n \n3\n,\n \nMatrix\n{\nFloat32\n})[\n3\n]\n\n\n\n\n\n\n3-element Array{Float32,1}:\n 1841.4   \n  225.324 \n   70.7084\n\n\n\n\n\n\n\nUse subset of SNPs\n\n\n\n\n# principal components using every other SNP capture about half the variance\n\n\nsrand\n(\n123\n)\n\n\npca\n(\nview\n(\nhapmap\n,\n \n:\n,\n \n1\n:\n2\n:\nsnps\n),\n \n3\n)[\n3\n]\n\n\n\n\n\n\n3-element Array{Float64,1}:\n 926.622 \n 113.188 \n  36.4866\n\n\n\n\n\n\n\nUse sparse matrix. For large data sets with majority of rare variants, \npca_sp\n is more efficient by first converting \nSnpArray\n to a sparse matrix (default is \nSparseMatrixCSC{Float64, Int64}\n) and then computing principal components using iterative algorithms.\n\n\n\n\n# approximately same answer if we use Float16 sparse matrix\n\n\nsrand\n(\n123\n)\n\n\npca_sp\n(\nhapmap\n,\n \n3\n,\n \nSparseMatrixCSC\n{\nFloat32\n,\n \nUInt32\n})[\n3\n]\n\n\n\n\n\n\n3-element Array{Float32,1}:\n 1841.39  \n  225.324 \n   70.7084", 
            "title": "SnpArray"
        }, 
        {
            "location": "/man/snparray/#snparray", 
            "text": "SnpArray  is an array of  Tuple{Bool,Bool}  and adopts the same coding as the  Plink binary format . If  A1  and  A2  are the two alleles, the coding rule is       Genotype  SnpArray      A1,A1  (false,false)    A1,A2  (false,true)    A2,A2  (true,true)    missing  (true,false)     The code  (true,false)  is reserved for missing genotype. Otherwise, the bit  true  represents one copy of allele  A2 . In a two-dimensional  SnpArray , each row is a person and each column is a SNP.  For complete genotype data, for example, after imputation, consider using the  HaplotypeArray  type.", 
            "title": "SnpArray"
        }, 
        {
            "location": "/man/snparray/#constructor", 
            "text": "There are various ways to initialize a  SnpArray .     SnpArray  can be initialized from  Plink binary files , say the sample data set hapmap3:   ; ls   - al   hapmap3.*   -rw-r--r--  1 huazhou  staff  1128171 Jun 19 14:43 hapmap3.bed\n-rw-r--r--  1 huazhou  staff   388672 Jun 19 14:43 hapmap3.bim\n-rw-r--r--  1 huazhou  staff     7136 Jun 19 14:43 hapmap3.fam\n-rw-r--r--  1 huazhou  staff   332960 Jun 19 14:43 hapmap3.map  using   SnpArrays  hapmap   =   SnpArray ( hapmap3 )   324\u00d713928 SnpArrays.SnpArray{2}:\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (false, true)  (false, true)      (false, true)  (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n \u22ee                                            \u22f1                             \n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)  By default, the constructor figures out the number of individuals and SNPs from the  .bim  and  .fam  files.  # rows are people; columns are SNPs  people ,   snps   =   size ( hapmap )   (324, 13928)  Alternatively, users can supply keyword arguments  people  and  snps  to the constructor. In this case only the  .bed  file needs to be present.  hapmap   =   SnpArray ( hapmap3 ;   people   =   324 ,   snps   =   13928 )   324\u00d713928 SnpArrays.SnpArray{2}:\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (false, true)  (false, true)      (false, true)  (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n \u22ee                                            \u22f1                             \n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)  Internally  SnpArray  stores data as  BitArray s and consumes approximately the same amount of memory as the Plink  bed  file size.  # memory usage, bed file size  Base . summarysize ( hapmap ),   filesize ( hapmap3.bed )   (1128256, 1128171)   SnpArray  can be initialized from a matrix of A1 allele counts.   SnpArray ( rand ( 0 : 2 ,   5 ,   3 ))   5\u00d73 SnpArrays.SnpArray{2}:\n (false, false)  (false, false)  (false, true) \n (true, true)    (true, true)    (false, true) \n (false, true)   (false, false)  (false, false)\n (false, false)  (false, true)   (false, true) \n (true, true)    (false, false)  (false, true)   SnpArray(m, n)  generates an m by n  SnpArray  of all A1 alleles.   s   =   SnpArray ( 5 ,   3 )   5\u00d73 SnpArrays.SnpArray{2}:\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)", 
            "title": "Constructor"
        }, 
        {
            "location": "/man/snparray/#summary-statistics", 
            "text": "summarize  function computes the following summary statistics of a  SnpArray :     maf : minor allele frequencies, taking into account of missingness.  minor_allele : a  BitVector  indicating the minor allele for each SNP.    minor_allele[j]==true  means A1 is the minor allele for SNP j;  minor_allele[j]==false  means A2 is the minor allele for SNP j.  missings_by_snp : number of missing genotypes for each snp.  missings_by_person : number of missing genotypes for each person.   maf ,   minor_allele ,   missings_by_snp ,   missings_by_person   =   summarize ( hapmap )  # minor allele frequencies  maf   1\u00d713928 RowVector{Float64,Array{Float64,1}}:\n 0.0  0.0776398  0.324074  0.191589  \u2026  0.00154321  0.0417957  0.00617284  # total number of missing genotypes  sum ( missings_by_snp ),   sum ( missings_by_person )   (11894, 11894)  # proportion of missing genotypes  sum ( missings_by_snp )   /   length ( hapmap )   0.0026356890108565393", 
            "title": "Summary statistics"
        }, 
        {
            "location": "/man/snparray/#filtering", 
            "text": "In almost all analyses, SNPs and individuals with low genotyping success rates are ignored. This filtering step is an important tool for removing likely false positives from association testing, as genotyping failure often occurs preferentially in cases or controls, or is correlated with the quantitative trait.  filter(s, min_success_rate_per_snp, min_success_rate_per_person)  does filtering according to the specified success rates for SNPs and people. Default is 0.98 for both.  # filtering SNPs and people to have both success rates above 0.98  snp_idx ,   person_idx   =   filter ( hapmap ,   0.98 ,   0.98 )  # summary statistics of the filtered SnpArray  _ ,   _ ,   missings_by_snp_filtered ,   missings_by_person_filtered   =   summarize ( hapmap [ person_idx ,   snp_idx ]);   # minimum SNP genotyping success rate after filtering \u2265 0.98  1.0   -   maximum ( missings_by_snp_filtered )   /   length ( missings_by_person_filtered )   0.9813084112149533  # minimum person genotyping success rate after filtering \u2265 0.98  1.0   -   maximum ( missings_by_person_filtered )   /   length ( missings_by_snp_filtered )   0.9818511796733213", 
            "title": "Filtering"
        }, 
        {
            "location": "/man/snparray/#random-genotypes-generation", 
            "text": "randgeno(a1freq)  generates a random genotype according to A1 allele frequency  a1freq .  randgeno ( 0.5 )   (false, true)  randgeno(maf, minor_allele)  generates a random genotype according to minor allele frequency  maf  and whether the minor allele is A1 ( minor_allele==true ) or A2 ( minor_allele==false ).  randgeno ( 0.25 ,   true )   (true, true)  randgeno(n, maf, minor_allele)  generates a vector of random genotypes according to a common minor allele frequency  maf  and the minor allele.  randgeno ( 10 ,   0.25 ,   true )   10-element SnpArrays.SnpArray{1}:\n (false, true)\n (true, true) \n (true, true) \n (false, true)\n (false, true)\n (false, true)\n (false, true)\n (true, true) \n (false, true)\n (true, true)  randgeno(m, n, maf, minor_allele)  generates a random $m$-by-$n$  SnpArray  according to a vector of minor allele frequencies  maf  and a minor allele indicator vector. The lengths of both vectors should be  n .  # this is a random replicate of the hapmap data  randgeno ( size ( hapmap ),   maf ,   minor_allele )   324\u00d713928 SnpArrays.SnpArray{2}:\n (true, true)  (true, true)   (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)       (false, true)  (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)       (true, true)   (true, true)\n \u22ee                                            \u22f1                             \n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (false, true)  (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)    \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)", 
            "title": "Random genotypes generation"
        }, 
        {
            "location": "/man/snparray/#subsetting", 
            "text": "Subsetting a  SnpArray  works the same way as subsetting any other arrays.  # genotypes of the 1st person  hapmap [ 1 ,   : ]   13928-element SnpArrays.SnpArray{1}:\n (true, true)  \n (true, true)  \n (false, false)\n (true, true)  \n (true, true)  \n (true, true)  \n (false, true) \n (false, true) \n (true, true)  \n (false, true) \n (true, true)  \n (true, true)  \n (false, false)\n \u22ee             \n (false, true) \n (false, true) \n (true, true)  \n (false, true) \n (false, true) \n (false, true) \n (false, true) \n (false, true) \n (false, true) \n (true, true)  \n (true, true)  \n (true, true)  # genotypes of the 5th SNP  hapmap [ : ,   5 ]   324-element SnpArrays.SnpArray{1}:\n (true, true)  \n (true, true)  \n (false, true) \n (false, true) \n (true, true)  \n (false, false)\n (false, false)\n (true, true)  \n (true, true)  \n (true, true)  \n (true, true)  \n (true, true)  \n (false, true) \n \u22ee             \n (false, false)\n (true, true)  \n (false, true) \n (true, true)  \n (true, true)  \n (true, true)  \n (true, true)  \n (true, true)  \n (false, true) \n (true, true)  \n (true, true)  \n (true, true)  # subsetting both persons and SNPs  hapmap [ 1 : 5 ,   5 : 10 ]   5\u00d76 SnpArrays.SnpArray{2}:\n (true, true)   (true, true)  (false, true)  \u2026  (true, true)   (false, true)\n (true, true)   (true, true)  (true, true)      (true, true)   (false, true)\n (false, true)  (true, true)  (true, true)      (false, true)  (true, true) \n (false, true)  (true, true)  (true, true)      (true, true)   (false, true)\n (true, true)   (true, true)  (true, true)      (true, true)   (false, true)  # filter out rare SNPs with MAF   0.05  hapmap [ : ,   maf   .\u2265   0.05 ]   324\u00d712085 SnpArrays.SnpArray{2}:\n (true, true)   (false, false)  \u2026  (false, true)  (false, true)\n (false, true)  (false, true)      (true, true)   (true, true) \n (true, true)   (false, true)      (true, true)   (true, true) \n (true, true)   (false, true)      (false, true)  (false, true)\n (true, true)   (false, true)      (true, true)   (true, true) \n (false, true)  (true, true)    \u2026  (false, true)  (false, true)\n (true, true)   (true, true)       (true, true)   (true, true) \n (true, true)   (false, false)     (true, true)   (true, true) \n (true, true)   (false, true)      (true, true)   (true, true) \n (true, true)   (false, true)      (false, true)  (false, true)\n (true, true)   (false, true)   \u2026  (true, true)   (true, true) \n (true, true)   (true, true)       (false, true)  (false, true)\n (true, true)   (false, false)     (false, true)  (false, true)\n \u22ee                              \u22f1                              \n (true, true)   (false, true)      (false, true)  (false, true)\n (true, true)   (false, false)     (false, true)  (false, true)\n (true, true)   (false, false)     (true, true)   (true, true) \n (true, true)   (false, false)  \u2026  (true, true)   (true, true) \n (true, true)   (false, true)      (true, true)   (true, true) \n (true, true)   (true, true)       (false, true)  (false, true)\n (true, true)   (false, true)      (false, true)  (false, true)\n (true, true)   (false, true)      (true, true)   (true, true) \n (true, true)   (false, false)  \u2026  (false, true)  (false, true)\n (true, true)   (false, true)      (false, true)  (false, true)\n (true, true)   (false, false)     (false, true)  (false, true)\n (true, true)   (false, false)     (true, true)   (true, true)  # filter out individuals with genotyping success rate   0.90  hapmap [ missings_by_person   /   people   .   0.1 ,   : ]   220\u00d713928 SnpArrays.SnpArray{2}:\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (false, true)  (false, true)      (false, true)  (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (false, true)  (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n (true, true)  (true, true)   (true, true)       (true, true)   (true, true)\n \u22ee                                            \u22f1                             \n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)  \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)   \u2026  (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, true)      (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)\n (true, true)  (true, true)   (false, false)     (true, true)   (true, true)  view  creates views of subarray without copying data and improve efficiency in many calculations.  mafcommon ,   =   summarize ( view ( hapmap ,   : ,   maf   .\u2265   0.05 ))  mafcommon   1\u00d712085 RowVector{Float64,Array{Float64,1}}:\n 0.0776398  0.324074  0.191589  \u2026  0.310937  0.23913  0.23913  0.23913", 
            "title": "Subsetting"
        }, 
        {
            "location": "/man/snparray/#assignment", 
            "text": "It is possible to assign specific genotypes to a  SnpArray  entry.  hapmap [ 1 ,   1 ]   (true, true)  hapmap [ 1 ,   1 ]   =   ( false ,   true )  hapmap [ 1 ,   1 ]   (false, true)  hapmap [ 1 ,   1 ]   =   NaN  hapmap [ 1 ,   1 ]   (true, false)  hapmap [ 1 ,   1 ]   =   2  hapmap [ 1 ,   1 ]   (true, true)  Subsetted assignment such as  hapmap[:, 1] = Nan  is also valid.", 
            "title": "Assignment"
        }, 
        {
            "location": "/man/snparray/#convert-copy-and-imputation", 
            "text": "In most analyses we convert a whole  SnpArray  or slices of it to numeric arrays (matrix of  minor allele counts ) for statistical analysis. Keep in mind that the storage of resultant data can be up to 32 fold larger than that of the original  SnpArray . Fortunately, rich collection of data types in  Julia  allow us choose one that fits into memory. Below are estimates of memory usage for some common data types with  n  persons and  p  SNPs. Here MAF denotes the  average  minor allele frequencies.   SnpArray : $0.25np$ bytes  Matrix{Int8} : $np$ bytes  Matrix{Float16} : $2np$ bytes  Matrix{Float32} : $4np$ bytes  Matrix{Float64} : $8np$ bytes  SparseMatrixCSC{Float64,Int64} : $16 \\cdot \\text{NNZ} + 8(p+1) \\approx 16np(2\\text{MAF}(1-\\text{MAF})+\\text{MAF}^2) + 8(p+1) = 16np \\cdot \\text{MAF}(2-\\text{MAF}) + 8(p+1)$ bytes. When the average MAF=0.25, this is about $7np$ bytes. When MAF=0.025, this is about $0.8np$ bypes, 10 fold smaller than the  Matrix{Float64}  type.  SparseMatrixCSC{Int8,UInt32} : $5 \\cdot \\text{NNZ} + 4(p+1) \\approx 5np(2\\text{MAF}(1-\\text{MAF})+\\text{MAF}^2) + 4(p+1) = 5np \\cdot \\text{MAF}(2-\\text{MAF}) + 4(p+1)$ bytes. When the average MAF=0.25, this is about $2.2np$ bytes. When MAF=0.08, this is about $0.8np$ bypes, 10 fold smaller than  Matrix{Float64}  type.  Two  SparseMatrixCSC{Bool,Int64} : $2np \\cdot \\text{MAF} \\cdot 9 + 16(p+1) = 18 np \\cdot \\text{MAF} + 16(p+1)$ bytes. When the average MAF=0.25, this is about $4.5np$ bytes. When MAF=0.045, this is about $0.8np$ bytes, 10 fold smaller than  Matrix{Float64}  type.   To be concrete, consider 2 typical data sets:     COPD (GWAS): $n = 6670$ individuals, $p = 630998$ SNPs, average MAF is 0.2454.  GAW19 (sequencing study): $n = 959$ individuals, $p = 8348674$ SNPs, average MAF is 0.085.      Data Type  COPD  GAW19      SnpArray  1.05GB  2GB    Matrix{Float64}  33.67GB  64.05GB    SparseMatrixCSC{Float64,Int64}  29GB  20.82GB    SparseMatrixCSC{Bool,Int64}  18.6GB  12.386GB     Apparently for data sets with a majority of rare variants, converting to sparse matrices saves memory and often brings computational advantages too. In the  SparseMatrixCSC  format, the integer type of the row indices  rowval  and column pointer  colptr  should have maximal allowable value larger than the number of nonzeros in the matrix. The  InexactError()  error encountered during conversion often indicates that the integer type has a too small range. The utility function  estimatesize  conveniently estimates memory usage in bytes for the input data type.  # estimated memory usage if convert to Matrix{Float64}  estimatesize ( people ,   snps ,   Matrix { Float64 })   3.6101376e7  # convert to Matrix{Float64}  hapmapf64   =   convert ( Matrix { Float64 },   hapmap )   324\u00d713928 Array{Float64,2}:\n 0.0  0.0  2.0  0.0  0.0  0.0  1.0  1.0  \u2026  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  1.0  1.0  1.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  1.0  1.0  1.0  0.0  0.0  2.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  1.0  0.0  0.0  1.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  2.0  0.0  0.0  0.0  \u2026  2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  2.0  0.0  0.0  2.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0  \u2026  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n \u22ee                        \u22ee              \u22f1                      \u22ee            \n 0.0  0.0  1.0  0.0  2.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  2.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  1.0  0.0  0.0  0.0  1.0  \u2026  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  1.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  1.0     2.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0  \u2026  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0  0.0  0.0  1.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  1.0  0.0  0.0  0.0  2.0     1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  2.0  0.0  0.0  0.0  0.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  # actual memory usage of Matrix{Float64}  Base . summarysize ( hapmapf64 )   36101376  # average maf of the hapmap3 data set  mean ( maf )   0.222585591341583  # estimated memory usage if convert to SparseMatrixCSC{Float32, UInt32} matrix  estimatesize ( people ,   snps ,   SparseMatrixCSC { Float32 ,   UInt32 },   mean ( maf ))   1.4338389205819245e7  # convert to SparseMatrixCSC{Float32, UInt32} matrix  hapmapf32sp   =   convert ( SparseMatrixCSC { Float32 ,   UInt32 },   hapmap )   324\u00d713928 SparseMatrixCSC{Float32,UInt32} with 1614876 stored entries:\n  [2    ,     2]  =  1.0\n  [6    ,     2]  =  1.0\n  [15   ,     2]  =  1.0\n  [31   ,     2]  =  1.0\n  [33   ,     2]  =  1.0\n  [35   ,     2]  =  1.0\n  [43   ,     2]  =  1.0\n  [44   ,     2]  =  1.0\n  [50   ,     2]  =  1.0\n  [54   ,     2]  =  1.0\n  \u22ee\n  [135  , 13927]  =  1.0\n  [148  , 13927]  =  1.0\n  [160  , 13927]  =  1.0\n  [164  , 13927]  =  2.0\n  [167  , 13927]  =  1.0\n  [185  , 13927]  =  1.0\n  [266  , 13927]  =  1.0\n  [280  , 13927]  =  1.0\n  [288  , 13927]  =  1.0\n  [118  , 13928]  =  2.0\n  [231  , 13928]  =  2.0  # actual memory usage if convert to SparseMatrixCSC{Float32, UInt32} matrix  Base . summarysize ( hapmapf32sp )   12974764  By default the  convert()  method converts missing genotypes to  NaN .  # number of missing genotypes  countnz ( isnan . ( hapmap )),   countnz ( isnan . ( hapmapf64 ))   (11894, 11894)  One can enforce  crude imputation  by setting the optional argument  impute=true . Imputation is done by generating two random alleles according to the minor allele frequency. This is a neutral but not an optimal strategy, and users should impute missing genotypes by more advanced methods.  hapmapf64impute   =   convert ( Matrix { Float64 },   hapmap ;   impute   =   true )  countnz ( isnan . ( hapmapf64impute ))   0  By default  convert()  translates genotypes according to the  additive  SNP model, which essentially counts the number of  minor allele  (0, 1 or 2) per genotype. Other SNP models are  dominant  and  recessive , both in terms of the  minor allele . When  A1  is the minor allele, genotypes are translated to real number according to     Genotype  SnpArray  model=:additive  model=:dominant  model=:recessive      A1,A1  (false,false)  2  1  1    A1,A2  (false,true)  1  1  0    A2,A2  (true,true)  0  0  0    missing  (true,false)  NaN  NaN  NaN     When  A2  is the minor allele, genotypes are translated according to     Genotype  SnpArray  model=:additive  model=:dominant  model=:recessive      A1,A1  (false,false)  0  0  0    A1,A2  (false,true)  1  1  0    A2,A2  (true,true)  2  1  1    missing  (true,false)  NaN  NaN  NaN     [ convert ( Vector { Float64 },   hapmap [ 1 : 10 ,   5 ];   model   =   : additive )   convert ( Vector { Float64 },   hapmap [ 1 : 10 ,   5 ];   model   =   : dominant )   convert ( Vector { Float64 },   hapmap [ 1 : 10 ,   5 ];   model   =   : recessive )]   10\u00d73 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 1.0  1.0  0.0\n 1.0  1.0  0.0\n 0.0  0.0  0.0\n 2.0  1.0  1.0\n 2.0  1.0  1.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0  By default  convert()  does  not  center and scale genotypes. Setting the optional arguments  center=true, scale=true  centers genotypes at 2MAF and scales them by $[2 \\cdot \\text{MAF} \\cdot (1 - \\text{MAF})]^{-1/2}$. Mono-allelic SNPs (MAF=0) are not scaled.  [ convert ( Vector { Float64 },   hapmap [ : ,   5 ])   convert ( Vector { Float64 },   hapmap [ : ,   5 ];   center   =   true ,   scale   =   true )]   324\u00d72 Array{Float64,2}:\n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n 1.0   0.167017\n 0.0  -1.25702 \n 2.0   1.59106 \n 2.0   1.59106 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n \u22ee             \n 2.0   1.59106 \n 0.0  -1.25702 \n 1.0   0.167017\n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702 \n 1.0   0.167017\n 0.0  -1.25702 \n 0.0  -1.25702 \n 0.0  -1.25702  copy!()  is the in-place version of  convert() . Options such as GWAS loop over SNPs and perform statistical anlaysis for each SNP. This can be achieved by  g   =   zeros ( people )  for   j   =   1 : snps \n     copy! ( g ,   hapmap [ : ,   j ];   model   =   : additive ,   impute   =   true ) \n     # do statistical anlaysis  end", 
            "title": "Convert, copy and imputation"
        }, 
        {
            "location": "/man/snparray/#empirical-kinship-matrix", 
            "text": "grm  function computes the empirical kinship matrix using either the genetic relationship matrix,  grm(A, model=:GRM) , or the method of moment method,  grm(A, model=:MoM) .    Note  Missing genotypes are imputed according to minor allele frequencies on the fly.    Note  It is often necessary to filter SNPs according to minor allele frequency and LD before calculating empirical kinship matrix.   By default,  grm  exlcude SNPs with minor allele frequency below 0.01. This can be changed by the keyword argument  maf_threshold .  # GRM using all SNPs with MAF \u2265 0.01. Same as  # grm(hapmap; maf_threshold = 0.01)  grm ( hapmap )   324\u00d7324 Array{Float64,2}:\n 0.571462   0.0465067  0.0198863  \u2026  0.065456   0.0716354  0.0653478\n 0.0465067  0.544896   0.028444      0.0515233  0.0456809  0.0633915\n 0.0198863  0.028444   0.520507      0.046051   0.0302884  0.0366246\n 0.0484459  0.0369766  0.0293501     0.060103   0.0660171  0.0601609\n 0.052807   0.0424252  0.0264585     0.0718885  0.0583893  0.0658839\n 0.0453662  0.0316632  0.0382386  \u2026  0.070662   0.0566399  0.0650759\n 0.0401015  0.022318   0.0119087     0.044437   0.0381739  0.0372612\n 0.0410669  0.0386841  0.0210986     0.0574887  0.0547491  0.0663823\n 0.0300075  0.0309477  0.0172097     0.0340103  0.0460311  0.0382384\n 0.0394993  0.0422916  0.0261469     0.0668     0.0576783  0.0493439\n 0.0480282  0.045924   0.0233717  \u2026  0.0586062  0.0628982  0.0611232\n 0.0605082  0.0394706  0.0379736     0.0660183  0.058135   0.0701802\n 0.0360314  0.0439399  0.02689       0.0572845  0.0701882  0.0637648\n \u22ee                                \u22f1                                 \n 0.0581814  0.0556006  0.0380623     0.0865167  0.0865612  0.0971798\n 0.0675241  0.0521455  0.0340608     0.0917849  0.0804942  0.0858172\n 0.0679571  0.0557595  0.0388875     0.0898047  0.0842924  0.0853568\n 0.0654182  0.0570707  0.0401996  \u2026  0.0874426  0.0763659  0.0889914\n 0.0626962  0.0556636  0.0368206     0.0788686  0.0730769  0.0814711\n 0.0648935  0.0612453  0.0397923     0.0890301  0.0900733  0.0818672\n 0.0623441  0.0600386  0.0386961     0.0821445  0.0851567  0.0805624\n 0.0620668  0.0630181  0.0336136     0.0933894  0.0899758  0.0865969\n 0.0657627  0.0631312  0.0334048  \u2026  0.0974675  0.0793873  0.0865828\n 0.065456   0.0515233  0.046051      0.603312   0.0821679  0.0903656\n 0.0716354  0.0456809  0.0302884     0.0821679  0.595324   0.0828236\n 0.0653478  0.0633915  0.0366246     0.0903656  0.0828236  0.582924  # GRM using all SNPs with MAF \u2265 0.05  grm ( hapmap ;   maf_threshold   =   0.05 )   324\u00d7324 Array{Float64,2}:\n 0.569832   0.0534955  0.0229106  \u2026  0.0736094  0.0777382  0.0728604\n 0.0534955  0.542797   0.0292553     0.0565556  0.050179   0.0687166\n 0.0229106  0.0292553  0.521398      0.0516482  0.03499    0.0406527\n 0.0531014  0.0397342  0.0315786     0.061866   0.0725732  0.0652814\n 0.0555008  0.0457758  0.0260288     0.0763692  0.063647   0.0720957\n 0.048623   0.0330879  0.041643   \u2026  0.0754922  0.0612846  0.0653836\n 0.0425229  0.0256048  0.0152978     0.0465058  0.038005   0.0432299\n 0.0445646  0.0417373  0.0241854     0.0573711  0.0568992  0.0665918\n 0.0315382  0.0336913  0.0200753     0.036809   0.0504817  0.0416076\n 0.041739   0.0440421  0.0298305     0.0711053  0.063812   0.0530766\n 0.0551959  0.0476215  0.0240236  \u2026  0.0627489  0.0680972  0.0673988\n 0.0662055  0.0427204  0.0409013     0.0744466  0.0654627  0.0733776\n 0.0363799  0.0475432  0.0301813     0.0635413  0.0731001  0.0677743\n \u22ee                                \u22f1                                 \n 0.0606893  0.0571803  0.0422398     0.0920599  0.0920055  0.105568 \n 0.072268   0.0547569  0.037554      0.0978259  0.0857098  0.0927913\n 0.0673625  0.0593351  0.0407456     0.0922872  0.0910686  0.0912259\n 0.0708107  0.0637208  0.0453826  \u2026  0.0935781  0.0829951  0.0937371\n 0.0693228  0.0591013  0.0387746     0.0862804  0.0816425  0.089975 \n 0.0694049  0.0632493  0.0442108     0.0936805  0.0956861  0.0892517\n 0.0662482  0.0621341  0.0401302     0.0862024  0.088719   0.087849 \n 0.0683031  0.0678069  0.0392417     0.0996427  0.0917543  0.0865936\n 0.07229    0.0673767  0.0390863  \u2026  0.106276   0.0842234  0.0901547\n 0.0736094  0.0565556  0.0516482     0.590262   0.0900209  0.094751 \n 0.0777382  0.050179   0.03499       0.0900209  0.587857   0.08857  \n 0.0728604  0.0687166  0.0406527     0.094751   0.08857    0.570328  # GRM using every other SNP, with maf \u2265 0.01  grm ( view ( hapmap ,   : ,   1 : 2 : snps ))   324\u00d7324 Array{Float64,2}:\n 0.558921   0.0430417  0.02776    \u2026  0.0675216  0.0737988  0.0675734\n 0.0430417  0.557352   0.0283227     0.0581735  0.0459756  0.0563325\n 0.02776    0.0283227  0.513037      0.0403644  0.0401923  0.0482823\n 0.0453687  0.0459315  0.0274437     0.0522127  0.062348   0.0567562\n 0.0525321  0.0482946  0.0261682     0.0675415  0.0565141  0.0658733\n 0.0527773  0.0407108  0.0395822  \u2026  0.0763428  0.0629453  0.0538004\n 0.0400413  0.0270224  0.0174656     0.0471662  0.0344731  0.0342288\n 0.0477958  0.0380087  0.026397      0.0591346  0.0559213  0.0690588\n 0.027236   0.0232717  0.0199212     0.0335014  0.0438624  0.0362997\n 0.0316181  0.0401905  0.0238639     0.0599384  0.04131    0.0507507\n 0.0489757  0.0506289  0.0211802  \u2026  0.0629766  0.0652554  0.0533221\n 0.0625952  0.0495802  0.040138      0.0663878  0.0647589  0.0606609\n 0.0255679  0.0432178  0.0227905     0.0548997  0.0688556  0.0638942\n \u22ee                                \u22f1                                 \n 0.0603235  0.0507125  0.0414195     0.0874199  0.0850151  0.102226 \n 0.0670063  0.0605808  0.0322251     0.0900799  0.0761188  0.0819028\n 0.0689632  0.0537943  0.0396167     0.0845196  0.0816942  0.0965653\n 0.0655601  0.0590466  0.0417276  \u2026  0.0933334  0.0772525  0.0827035\n 0.0632019  0.0619054  0.0411649     0.0734338  0.0695185  0.0872505\n 0.0667202  0.0637907  0.0420585     0.0769856  0.0831787  0.0846128\n 0.0630419  0.0648211  0.0313507     0.0866063  0.0920158  0.0833748\n 0.059878   0.0622266  0.0347955     0.0952744  0.0918524  0.0842268\n 0.0763973  0.0662859  0.0401014  \u2026  0.102024   0.0748581  0.0900122\n 0.0675216  0.0581735  0.0403644     0.573673   0.0699285  0.0957602\n 0.0737988  0.0459756  0.0401923     0.0699285  0.576885   0.0749023\n 0.0675734  0.0563325  0.0482823     0.0957602  0.0749023  0.588357  # MoM using all SNPs with MAF \u2265 0.01  grm ( hapmap ;   method   =   : MoM )   324\u00d7324 Array{Float64,2}:\n 0.539557    0.0352687  0.00335917  \u2026  0.0544144  0.0642236  0.0514598\n 0.0352687   0.51793    0.0137593      0.0424779  0.0395233  0.0507507\n 0.00335917  0.0137593  0.499611       0.0319596  0.0207321  0.0199049\n 0.0440143   0.0292413  0.0234504      0.0527598  0.0698964  0.0501598\n 0.0455507   0.0333778  0.0156502      0.0656418  0.0571326  0.0567781\n 0.0324323   0.0209685  0.0259322   \u2026  0.0593781  0.0495689  0.0488598\n 0.0252231   0.0111593  0.00288644     0.0314868  0.0314868  0.0247504\n 0.0256958   0.0285322  0.00915016     0.0388142  0.0466143  0.047087 \n 0.0209685   0.0253413  0.012932       0.0297141  0.0486234  0.0306595\n 0.0210867   0.0255777  0.010332       0.0529962  0.0507507  0.0325505\n 0.0364505   0.0337323  0.00548647  \u2026  0.0498053  0.0561872  0.0501598\n 0.0488598   0.0323141  0.0275868      0.0559508  0.0553599  0.0524053\n 0.0314868   0.0415324  0.0242776      0.0587872  0.0710783  0.0580781\n \u22ee                                  \u22f1                                 \n 0.0421233   0.0411779  0.0253413      0.0708419  0.0797057  0.0819511\n 0.0624509   0.0482689  0.0269959      0.0919967  0.0795875  0.0837239\n 0.0551235   0.0449597  0.0261686      0.0804148  0.0817148  0.0726147\n 0.0459052   0.0423597  0.0242776   \u2026  0.0727328  0.0630418  0.0706055\n 0.0561872   0.0532326  0.0295959      0.0782875  0.0711965  0.074742 \n 0.0533508   0.0544144  0.0308959      0.0789966  0.0864421  0.0722601\n 0.0526417   0.0509871  0.0295959      0.0778147  0.0845512  0.0745056\n 0.0492143   0.052878   0.0209685      0.0823057  0.0845512  0.0724965\n 0.0506325   0.0481507  0.0221503   \u2026  0.0883331  0.0740329  0.0696601\n 0.0544144   0.0424779  0.0319596      0.561421   0.0811239  0.0766329\n 0.0642236   0.0395233  0.0207321      0.0811239  0.56733    0.0695419\n 0.0514598   0.0507507  0.0199049      0.0766329  0.0695419  0.533766", 
            "title": "Empirical kinship matrix"
        }, 
        {
            "location": "/man/snparray/#principal-components", 
            "text": "Principal compoenent analysis is widely used in genome-wide association analysis (GWAS) for adjusting population substructure.  pca(A, pcs)  computes the top  pcs  principal components of a  SnpArray . Each SNP is centered at $2\\text{MAF}$ and scaled by $[2\\text{MAF}(1-\\text{MAF})]^{-1/2}$. The output is     pcscore : top  pcs  eigen-SNPs, or principal scores, in each column  pcloading : top  pcs  eigen-vectors, or principal loadings, in each column  pcvariance : top  pcs  eigen-values, or principal variances   Missing genotypes are imputed according the minor allele frequencies on the fly. This implies that, in the presence of missing genotypes, running the function on the same  SnpArray  twice may produce slightly different answers. For reproducibility, it is a good practice to set the random seed before each function that does imputation on the fly.  srand ( 123 )   # set seed  pcscore ,   pcloading ,   pcvariance   =   pca ( hapmap ,   3 )   ([-38.7231 -1.2983 -7.00541; -32.6096 -1.21052 -3.3232; \u2026 ; -48.9263 -2.06102 2.17374; -48.8627 0.274894 6.49518], [7.47821e-19 1.01333e-18 1.65076e-19; 0.00143962 -0.0042375 -0.00311816; \u2026 ; 0.00313326 -0.00427486 -0.0152038; -9.09523e-5 -0.00287777 0.0037855], [1841.4, 225.324, 70.7084])  To use eigen-SNPs for plotting or as covariates in GWAS, we typically scale them by their standard deviations so that they have mean zero and unit variance.  # standardize eigen-SNPs before plotting or GWAS  scale! ( pcscore ,   1   ./   sqrt . ( pcvariance ))  std ( pcscore ,   1 )   1\u00d73 Array{Float64,2}:\n 1.0  1.0  1.0  Internally  pca  converts  SnpArray  to the matrix of minor allele counts. The default format is  Matrix{Float64} , which can easily exceed memory limit. Users have several options when the default  Matrix{Float64}  cannot fit into memory.     Use other intermediate matrix types.   # use single precision matrix and display the principal variances  # approximately same answer as double precision  srand ( 123 )  pca ( hapmap ,   3 ,   Matrix { Float32 })[ 3 ]   3-element Array{Float32,1}:\n 1841.4   \n  225.324 \n   70.7084   Use subset of SNPs   # principal components using every other SNP capture about half the variance  srand ( 123 )  pca ( view ( hapmap ,   : ,   1 : 2 : snps ),   3 )[ 3 ]   3-element Array{Float64,1}:\n 926.622 \n 113.188 \n  36.4866   Use sparse matrix. For large data sets with majority of rare variants,  pca_sp  is more efficient by first converting  SnpArray  to a sparse matrix (default is  SparseMatrixCSC{Float64, Int64} ) and then computing principal components using iterative algorithms.   # approximately same answer if we use Float16 sparse matrix  srand ( 123 )  pca_sp ( hapmap ,   3 ,   SparseMatrixCSC { Float32 ,   UInt32 })[ 3 ]   3-element Array{Float32,1}:\n 1841.39  \n  225.324 \n   70.7084", 
            "title": "Principal components"
        }, 
        {
            "location": "/man/snpdata/", 
            "text": "SnpData\n\n\nSnpData\n stores all SNP information in addition to genotypes. We initialize \nSnpData\n from Plink binary files. Note all three Plink files \n.bed\n, \n.bim\n and \n.fam\n need to be present.\n\n\nusing\n \nSnpArrays\n\n\nhapmap_snpdata\n \n=\n \nSnpData\n(\nhapmap3\n)\n\n\nfieldnames\n(\nhapmap_snpdata\n)\n\n\n\n\n\n\n14-element Array{Symbol,1}:\n :people             \n :snps               \n :personid           \n :snpid              \n :chromosome         \n :genetic_distance   \n :basepairs          \n :allele1            \n :allele2            \n :maf                \n :minor_allele       \n :snpmatrix          \n :missings_per_person\n :missings_per_snp\n\n\n\n\n\nhapmap_snpdata\n.\nsnpid\n[\n1\n:\n10\n]\n\n\n\n\n\n\n10-element Array{AbstractString,1}:\n \nrs10458597\n\n \nrs12562034\n\n \nrs2710875\n \n \nrs11260566\n\n \nrs1312568\n \n \nrs35154105\n\n \nrs16824508\n\n \nrs2678939\n \n \nrs7553178\n \n \nrs13376356\n\n\n\n\n\n\nhapmap_snpdata\n.\npersonid\n[\n1\n:\n10\n]\n\n\n\n\n\n\n10-element Array{AbstractString,1}:\n \nNA19916\n\n \nNA19835\n\n \nNA20282\n\n \nNA19703\n\n \nNA19901\n\n \nNA19908\n\n \nNA19914\n\n \nNA20287\n\n \nNA19713\n\n \nNA19904\n\n\n\n\n\n\nTo write \nSnpData\n to Plink \nbed\n and \nbim\n files, we use \nwriteplink(filename, snpdata)\n.\n\n\n#writeplink(filename, hapmap_snpdata)", 
            "title": "SnpData"
        }, 
        {
            "location": "/man/snpdata/#snpdata", 
            "text": "SnpData  stores all SNP information in addition to genotypes. We initialize  SnpData  from Plink binary files. Note all three Plink files  .bed ,  .bim  and  .fam  need to be present.  using   SnpArrays  hapmap_snpdata   =   SnpData ( hapmap3 )  fieldnames ( hapmap_snpdata )   14-element Array{Symbol,1}:\n :people             \n :snps               \n :personid           \n :snpid              \n :chromosome         \n :genetic_distance   \n :basepairs          \n :allele1            \n :allele2            \n :maf                \n :minor_allele       \n :snpmatrix          \n :missings_per_person\n :missings_per_snp  hapmap_snpdata . snpid [ 1 : 10 ]   10-element Array{AbstractString,1}:\n  rs10458597 \n  rs12562034 \n  rs2710875  \n  rs11260566 \n  rs1312568  \n  rs35154105 \n  rs16824508 \n  rs2678939  \n  rs7553178  \n  rs13376356   hapmap_snpdata . personid [ 1 : 10 ]   10-element Array{AbstractString,1}:\n  NA19916 \n  NA19835 \n  NA20282 \n  NA19703 \n  NA19901 \n  NA19908 \n  NA19914 \n  NA20287 \n  NA19713 \n  NA19904   To write  SnpData  to Plink  bed  and  bim  files, we use  writeplink(filename, snpdata) .  #writeplink(filename, hapmap_snpdata)", 
            "title": "SnpData"
        }, 
        {
            "location": "/man/haplotypearray/", 
            "text": "HaplotypeArray\n\n\nThe \nHaplotypeArray\n type is similar to \nSnpArray\n, but with two key differences:  \n\n\n\n\nThe two alleles are ordered, therefore (A1, A2) is different from (A2, A1);\n\n\nThe code \n(true,false)\n means the genotype (A2, A1), instead of the missing genotype in \nSnpArray\n.\n\n\n\n\n\n\n\n\n\n\nGenotype\n\n\nHaplotypeArray\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n(false,false)\n\n\n\n\n\n\nA1,A2\n\n\n(false,true)\n\n\n\n\n\n\nA2,A1\n\n\n(true,false)\n\n\n\n\n\n\nA2,A2\n\n\n(true,true)\n\n\n\n\n\n\n\n\nEach bit \ntrue\n in \nHaplotypeArray\n indicates a copy of the A2 allele. \n\n\n\n\nConstructor\n\n\nThere are various ways to initialize a \nHaplotypeArray\n.  \n\n\n\n\nHaplotypeArray\n can be intialized from two \nBitArray\ns. Each \nBitArray\n indicates an A2 allele copy in the first and second positions respectively.\n\n\n\n\nusing\n \nSnpArrays\n\n\nh\n \n=\n \nHaplotypeArray\n(\nbitrand\n(\n5\n,\n \n3\n),\n \nbitrand\n(\n5\n,\n \n3\n))\n\n\n\n\n\n\n5\u00d73 SnpArrays.HaplotypeArray{2}:\n (true, false)  (false, true)   (true, false) \n (true, true)   (false, false)  (true, false) \n (true, false)  (true, true)    (true, false) \n (true, false)  (false, false)  (false, false)\n (false, true)  (true, false)   (false, false)\n\n\n\n\n\n\n\nHaplotypeArray\n can be intialized from a \nSnpArray\n.\n\n\n\n\ns\n \n=\n \nSnpArray\n(\nbitrand\n(\n5\n,\n \n3\n),\n \nbitrand\n(\n5\n,\n \n3\n))\n\n\nh\n \n=\n \nHaplotypeArray\n(\ns\n)\n\n\n\n\n\n\n5\u00d73 SnpArrays.HaplotypeArray{2}:\n (false, true)   (true, true)    (false, true) \n (true, false)   (true, false)   (true, true)  \n (false, false)  (false, false)  (false, true) \n (false, false)  (false, false)  (true, false) \n (true, true)    (true, false)   (false, false)\n\n\n\n\n\nThis constructor does \nnot\n copy data from \nSnpArray\n. Therefore both \nh\n and \ns\n points to the same patch of memory. Only the interpretation of \n(true, false)\n changes.\n\n\nisnan\n(\ns\n)\n\n\n\n\n\n\n5\u00d73 BitArray{2}:\n false  false  false\n  true   true  false\n false  false  false\n false  false   true\n false   true  false\n\n\n\n\n\nisnan\n(\nh\n)\n\n\n\n\n\n\n5\u00d73 BitArray{2}:\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n\n\n\n\n\nChanges to \nh\n also effect \ns\n.\n\n\nh\n[\nisnan\n(\ns\n)]\n \n=\n \n(\ntrue\n,\n \ntrue\n)\n\n\nisnan\n(\ns\n)\n\n\n\n\n\n\n5\u00d73 BitArray{2}:\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n\n\n\n\n\n\n\nHaplotypeArray(m, n)\n generates an m by n \nHaplotypeArray\n of all A1 alleles.\n\n\n\n\nHaplotypeArray\n(\n5\n,\n \n3\n)\n\n\n\n\n\n\n5\u00d73 SnpArrays.HaplotypeArray{2}:\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n\n\n\n\n\n\n\nSummary statistics\n\n\nsummarize\n when applied to a \nHaplotypeArray\n only computes  \n\n\n\n\nmaf\n: minor allele frequencies, taking into account of missingness.\n\n\nminor_allele\n: a \nBitVector\n indicating the minor allele for each SNP.   \nminor_allele[j]==true\n means A1 is the minor allele for SNP j; \nminor_allele[j]==false\n means A2 is the minor allele for SNP j.\n\n\n\n\nmaf\n,\n \nminor_allele\n \n=\n \nsummarize\n(\nh\n)\n\n\n\n\n\n\n([0.5, 0.4, 0.4], Bool[false, true, true])\n\n\n\n\n\n\n\nSubsetting and assignment\n\n\nSubsetting and assignment work the same as \nSnpArray\n.\n\n\n\n\nCopy and convert\n\n\nCopying or converting a \nHaplotypeArray\n or slices of it to numeric arrays of \nminor allele counts\n is similar to \nSnpArray\n with the exception there are no missing genotypes in \nHaplotypeArray\n. So the keyword \nimpute\n is not relevant anymore.\n\n\n# convert to Matrix{Float64}\n\n\nh_f64\n \n=\n \nconvert\n(\nMatrix\n{\nFloat64\n},\n \nh\n)\n\n\n\n\n\n\n5\u00d73 Array{Float64,2}:\n 1.0  0.0  1.0\n 2.0  0.0  0.0\n 0.0  2.0  1.0\n 0.0  2.0  0.0\n 2.0  0.0  2.0\n\n\n\n\n\nBy default \nconvert\n translates genotypes according to the \nadditive\n SNP model, which essentially counts the number of \nminor allele\n (0, 1 or 2) per genotype. Other SNP models are \ndominant\n and \nrecessive\n, both in terms of the \nminor allele\n. When \nA1\n is the minor allele, genotypes are translated to real number according to\n\n\n\n\n\n\n\n\nGenotype\n\n\nHaplotypeArray\n\n\nmodel=:additive\n\n\nmodel=:dominant\n\n\nmodel=:recessive\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n00\n\n\n2\n\n\n1\n\n\n1\n\n\n\n\n\n\nA1,A2\n\n\n01\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A1\n\n\n10\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A2\n\n\n11\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\nWhen \nA2\n is the minor allele, genotypes are translated according to\n\n\n\n\n\n\n\n\nGenotype\n\n\nHaplotypeArray\n\n\nmodel=:additive\n\n\nmodel=:dominant\n\n\nmodel=:recessive\n\n\n\n\n\n\n\n\n\n\nA1,A1\n\n\n00\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\nA1,A2\n\n\n01\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A1\n\n\n01\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n\n\nA2,A2\n\n\n11\n\n\n2\n\n\n1\n\n\n1\n\n\n\n\n\n\n\n\n[\nconvert\n(\nVector\n{\nFloat64\n},\n \nh\n[\n1\n:\n5\n,\n \n3\n];\n \nmodel\n \n=\n \n:\nadditive\n)\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nh\n[\n1\n:\n5\n,\n \n3\n];\n \nmodel\n \n=\n \n:\ndominant\n)\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nh\n[\n1\n:\n5\n,\n \n3\n];\n \nmodel\n \n=\n \n:\nrecessive\n)]\n\n\n\n\n\n\n5\u00d73 Array{Float64,2}:\n 1.0  1.0  0.0\n 0.0  0.0  0.0\n 1.0  1.0  0.0\n 0.0  0.0  0.0\n 2.0  1.0  1.0\n\n\n\n\n\nBy default \nconvert\n does \nnot\n center and scale genotypes. Setting the optional arguments \ncenter=true, scale=true\n centers genotypes at 2MAF and scales them by $[2 \\cdot \\text{MAF} \\cdot (1 - \\text{MAF})]^{-1/2}$. Mono-allelic SNPs (MAF=0) are not scaled.\n\n\n[\nconvert\n(\nVector\n{\nFloat64\n},\n \nh\n[\n:\n,\n \n3\n])\n \nconvert\n(\nVector\n{\nFloat64\n},\n \nh\n[\n:\n,\n \n3\n];\n \ncenter\n \n=\n \ntrue\n,\n \nscale\n \n=\n \ntrue\n)]\n\n\n\n\n\n\n5\u00d72 Array{Float64,2}:\n 1.0   0.288675\n 0.0  -1.1547  \n 1.0   0.288675\n 0.0  -1.1547  \n 2.0   1.73205\n\n\n\n\n\ncopy!\n is the in-place version of \nconvert()\n. Options such as GWAS loop over SNPs and perform statistical anlaysis for each SNP. This can be achieved by\n\n\ng\n \n=\n \nzeros\n(\nsize\n(\nh\n,\n \n1\n))\n\n\nfor\n \nj\n \n=\n \n1\n:\nsize\n(\nh\n,\n \n2\n)\n\n    \ncopy!\n(\ng\n,\n \nh\n[\n:\n,\n \nj\n];\n \nmodel\n \n=\n \n:\nadditive\n)\n\n    \n# do statistical anlaysis\n\n\nend", 
            "title": "HaplotypeArray"
        }, 
        {
            "location": "/man/haplotypearray/#haplotypearray", 
            "text": "The  HaplotypeArray  type is similar to  SnpArray , but with two key differences:     The two alleles are ordered, therefore (A1, A2) is different from (A2, A1);  The code  (true,false)  means the genotype (A2, A1), instead of the missing genotype in  SnpArray .      Genotype  HaplotypeArray      A1,A1  (false,false)    A1,A2  (false,true)    A2,A1  (true,false)    A2,A2  (true,true)     Each bit  true  in  HaplotypeArray  indicates a copy of the A2 allele.", 
            "title": "HaplotypeArray"
        }, 
        {
            "location": "/man/haplotypearray/#constructor", 
            "text": "There are various ways to initialize a  HaplotypeArray .     HaplotypeArray  can be intialized from two  BitArray s. Each  BitArray  indicates an A2 allele copy in the first and second positions respectively.   using   SnpArrays  h   =   HaplotypeArray ( bitrand ( 5 ,   3 ),   bitrand ( 5 ,   3 ))   5\u00d73 SnpArrays.HaplotypeArray{2}:\n (true, false)  (false, true)   (true, false) \n (true, true)   (false, false)  (true, false) \n (true, false)  (true, true)    (true, false) \n (true, false)  (false, false)  (false, false)\n (false, true)  (true, false)   (false, false)   HaplotypeArray  can be intialized from a  SnpArray .   s   =   SnpArray ( bitrand ( 5 ,   3 ),   bitrand ( 5 ,   3 ))  h   =   HaplotypeArray ( s )   5\u00d73 SnpArrays.HaplotypeArray{2}:\n (false, true)   (true, true)    (false, true) \n (true, false)   (true, false)   (true, true)  \n (false, false)  (false, false)  (false, true) \n (false, false)  (false, false)  (true, false) \n (true, true)    (true, false)   (false, false)  This constructor does  not  copy data from  SnpArray . Therefore both  h  and  s  points to the same patch of memory. Only the interpretation of  (true, false)  changes.  isnan ( s )   5\u00d73 BitArray{2}:\n false  false  false\n  true   true  false\n false  false  false\n false  false   true\n false   true  false  isnan ( h )   5\u00d73 BitArray{2}:\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n false  false  false  Changes to  h  also effect  s .  h [ isnan ( s )]   =   ( true ,   true )  isnan ( s )   5\u00d73 BitArray{2}:\n false  false  false\n false  false  false\n false  false  false\n false  false  false\n false  false  false   HaplotypeArray(m, n)  generates an m by n  HaplotypeArray  of all A1 alleles.   HaplotypeArray ( 5 ,   3 )   5\u00d73 SnpArrays.HaplotypeArray{2}:\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)\n (false, false)  (false, false)  (false, false)", 
            "title": "Constructor"
        }, 
        {
            "location": "/man/haplotypearray/#summary-statistics", 
            "text": "summarize  when applied to a  HaplotypeArray  only computes     maf : minor allele frequencies, taking into account of missingness.  minor_allele : a  BitVector  indicating the minor allele for each SNP.    minor_allele[j]==true  means A1 is the minor allele for SNP j;  minor_allele[j]==false  means A2 is the minor allele for SNP j.   maf ,   minor_allele   =   summarize ( h )   ([0.5, 0.4, 0.4], Bool[false, true, true])", 
            "title": "Summary statistics"
        }, 
        {
            "location": "/man/haplotypearray/#subsetting-and-assignment", 
            "text": "Subsetting and assignment work the same as  SnpArray .", 
            "title": "Subsetting and assignment"
        }, 
        {
            "location": "/man/haplotypearray/#copy-and-convert", 
            "text": "Copying or converting a  HaplotypeArray  or slices of it to numeric arrays of  minor allele counts  is similar to  SnpArray  with the exception there are no missing genotypes in  HaplotypeArray . So the keyword  impute  is not relevant anymore.  # convert to Matrix{Float64}  h_f64   =   convert ( Matrix { Float64 },   h )   5\u00d73 Array{Float64,2}:\n 1.0  0.0  1.0\n 2.0  0.0  0.0\n 0.0  2.0  1.0\n 0.0  2.0  0.0\n 2.0  0.0  2.0  By default  convert  translates genotypes according to the  additive  SNP model, which essentially counts the number of  minor allele  (0, 1 or 2) per genotype. Other SNP models are  dominant  and  recessive , both in terms of the  minor allele . When  A1  is the minor allele, genotypes are translated to real number according to     Genotype  HaplotypeArray  model=:additive  model=:dominant  model=:recessive      A1,A1  00  2  1  1    A1,A2  01  1  1  0    A2,A1  10  1  1  0    A2,A2  11  0  0  0     When  A2  is the minor allele, genotypes are translated according to     Genotype  HaplotypeArray  model=:additive  model=:dominant  model=:recessive      A1,A1  00  0  0  0    A1,A2  01  1  1  0    A2,A1  01  1  1  0    A2,A2  11  2  1  1     [ convert ( Vector { Float64 },   h [ 1 : 5 ,   3 ];   model   =   : additive )   convert ( Vector { Float64 },   h [ 1 : 5 ,   3 ];   model   =   : dominant )   convert ( Vector { Float64 },   h [ 1 : 5 ,   3 ];   model   =   : recessive )]   5\u00d73 Array{Float64,2}:\n 1.0  1.0  0.0\n 0.0  0.0  0.0\n 1.0  1.0  0.0\n 0.0  0.0  0.0\n 2.0  1.0  1.0  By default  convert  does  not  center and scale genotypes. Setting the optional arguments  center=true, scale=true  centers genotypes at 2MAF and scales them by $[2 \\cdot \\text{MAF} \\cdot (1 - \\text{MAF})]^{-1/2}$. Mono-allelic SNPs (MAF=0) are not scaled.  [ convert ( Vector { Float64 },   h [ : ,   3 ])   convert ( Vector { Float64 },   h [ : ,   3 ];   center   =   true ,   scale   =   true )]   5\u00d72 Array{Float64,2}:\n 1.0   0.288675\n 0.0  -1.1547  \n 1.0   0.288675\n 0.0  -1.1547  \n 2.0   1.73205  copy!  is the in-place version of  convert() . Options such as GWAS loop over SNPs and perform statistical anlaysis for each SNP. This can be achieved by  g   =   zeros ( size ( h ,   1 ))  for   j   =   1 : size ( h ,   2 ) \n     copy! ( g ,   h [ : ,   j ];   model   =   : additive ) \n     # do statistical anlaysis  end", 
            "title": "Copy and convert"
        }
    ]
}